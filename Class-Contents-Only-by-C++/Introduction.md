# 绪论

## 数据结构 (Data Structures)

### 数据结构的定义

数据结构是一组具有特定关系的同类数据元素的集合。它是组织和存储数据的方法，以便可以有效地访问和修改数据。

它包含三个要素：

- **数据的逻辑结构**：数据元素之间的逻辑关系，包括**集合（无关系）**、**线性结构（一对一）**、**树形结构（一对多）**、**图形结构（多对多）**。
- **数据的存储结构**：数据逻辑结构在计算机内的存储方式，如**顺序存储**、**链式存储**、**索引存储**、**散列存储**。
- **操作定义与实现**：对数据的操作，包括操作的定义（独立于计算机的现实问题抽象）和实现（基于存储结构的计算机和程序设计语言实现）。

#### 数据的逻辑结构

| 数据逻辑结构   | 关系类型     | 特点                                       | 举例                                       |
|-------------|------------|------------------------------------------|-------------------------------------------|
| 集合 (Set)       | 无关系       | 数据元素之间没有特定关系，独立存在               | 一组无特定顺序的城市名称                     |
| 线性结构 (Linear Structure) | 一对一关系     | 数据元素之间形成一个序列                         | 数组、链表（如排队）                    |
| 树形结构 (Tree Structure) | 一对多关系     | 数据元素之间形成层次结构                         | 二叉树、多叉树（如公司组织架构）            |
| 图形结构 (Graph Structure) | 多对多关系     | 数据元素之间可以有复杂的多对多关系               | 社交网络中的人际关系网络                     |

#### 数据的存储结构

数据的存储结构，也被称为数据的物理结构，是指数据在计算机内存中的**组织和存储方式**。这种存储方式直接影响到数据的检索、访问和更新的效率。

主要有以下几种存储结构：

1. **顺序存储 (Sequential Storage)**：
   - **定义**：将数据元素存放在一段**连续**的存储空间中。
   - **特点**：数据元素的物理位置（内存中的位置）紧邻彼此，反映了它们之间的逻辑关系。
   - **例子**：数组是典型的顺序存储结构。在数组中，每个元素都有固定的位置索引，可以通过计算直接访问。

2. **链式存储 (Linked Storage)**：
   - **定义**：数据元素存储在**不连续的、分散的**空间中，每个数据元素（节点）包含**数据部分**和指向其他元素的**指针**（链接）。
   - **特点**：逻辑上相邻的元素在物理上不一定相邻，每个元素都指向下一个元素的位置。
   - **例子**：链表（单链表、双向链表）是链式存储的典型应用。在链表中，每个节点包含数据和指向下一个节点的指针。

3. **索引存储 (Indexed Storage)**：
   - **定义**：除了存储数据元素，还维护一个**索引表**，表中每项包含关键字和数据元素的地址。
   - **特点**：通过索引表快速查找数据，关键字唯一标识一个数据元素。
   - **例子**：数据库中的索引机制。通过索引（例如，主键），可以快速定位到特定的数据记录。

4. **散列存储 (Hashing or Hash Storage)**：
   - **定义**：使用散列（哈希）函数处理关键字，将数据元素存储在一个连续的存储区域内。
   - **特点**：通过哈希函数计算出每个元素的存储位置，理想情况下能实现快速的数据访问。
   - **例子**：散列表（哈希表）。根据关键字的哈希值直接访问对应的数据元素。

四种存储方式优缺点分析：

| 存储方式        | 优点                                      | 缺点                                      |
|-----------------|------------------------------------------|-------------------------------------------|
| 顺序存储 (Sequential Storage) | 简单高效；直接访问元素快速 | 固定的存储空间可能导致空间浪费或限制       |
| 链式存储 (Linked Storage) | 灵活，易于扩展；无需预先分配固定空间 | 增加额外存储需求（存储指针）；访问时间可能增加 |
| 索引存储 (Indexed Storage) | 通过索引快速访问数据；适合复杂查询 | 维护索引本身有成本；增加了数据结构的复杂性 |
| 散列存储 (Hash Storage) | 高效的访问和搜索；理想状态下近似常数时间访问 | 需要良好的哈希函数避免冲突；处理冲突增加复杂性 |

#### 操作定义与实现

1. **操作定义 (Operation Definition)**：
   - **含义**：对现实问题的**抽象**，它描述了操作的目的和逻辑，而不涉及**具体的实现细节**。
   - **特点**：它独立于计算机，即操作定义不关心数据是如何在计算机内存中存储的。
   - **举例**：如果考虑一个超市里的商品管理系统，操作定义可以是“查找商品”、“添加商品”、“删除商品”等。这些定义描述了可以执行的操作，但不涉及这些操作是如何在计算机系统中实现的。

2. **操作实现 (Operation Implementation)**：
   - **含义**：在特定的数据存储结构上完成的**具体实现**，它依赖于计算机和具体的程序设计语言。
   - **特点**：操作实现关心数据如何在内存中表示、操作如何在这种表示上执行，以及如何有效地利用计算机资源。
   - **举例**：在超市商品管理系统中，实现“查找商品”的操作可能涉及在数组或数据库中搜索特定的商品信息。具体实现会使用特定的编程语言，并考虑数据存储的方式（如数组、链表、散列表等）。

### 抽象数据类型（ADT）

抽象数据类型（ADT, Abstract Data Type）是一种以**数学模型**定义的数据类型，关注数据的**逻辑特性**而不关注具体实现。可以将其视为对数据和操作的抽象描述，它定义了数据应如何存储、操作以及这些操作遵循的规则，但不涉及具体的编程语言实现。这使得ADT在不同编程环境中都具有通用性和可移植性。

举个具体的例子，抽象数据类型可以定义一个“栈（Stack）”：

- **数据元素**：栈中的元素。
- **数据关系**：先进后出（FILO）、后进先出（LIFO）。
- **基本操作**：如 `push`（添加元素到栈顶）、`pop`（从栈顶移除元素）、`peek`（查看栈顶元素而不移除它）。

在这个例子中，我们并不关心栈是如何在内存中存储的（使用数组还是链表等），只关心栈的逻辑特性和它提供的操作。

故抽象数据类型提供了一种高度抽象的视角来看待数据结构，它关注“做什么”而不是“怎么做”，使得同样的数据结构可以在不同的编程环境下以不同的方式实现。

### 我们需要学习的数据结构

1. **线性结构 (Linear Structures)**：
   - **数组 (Array)**：一组固定大小的数据项，通常是**相同类型**，存储在**连续**的内存位置中。
   - **链表 (Linked List)**：由**节点（Node）**组成的集合，每个节点包含**数据部分**和指向下一个节点的**指针**。
   - **栈 (Stack)**：后进先出（LIFO, Last-In-First-Out）的数据结构。
   - **队列 (Queue)**：先进先出（FIFO, First-In-First-Out）的数据结构。

2. **非线性结构 (Non-Linear Structures)**：
   - **树 (Tree)**：一个节点作为根，其余节点通过边与之连接，且没有环的图。
     - **二叉树 (Binary Tree)**：每个节点最多有两个子节点。
     - **平衡树 (Balanced Tree)**：如 AVL 树，确保树的高度保持在对数级别，优化搜索操作。
     - **堆 (Heap)**：特殊的树形结构，常用于实现**优先队列**。
   - **图 (Graph)**：由节点（或顶点）和边组成的集合，可以是有向的（Directed）也可以是无向的（Undirected）。

3. **特殊类型 (Specialized Types)**：
   - **散列表 (Hash Table)**：通过**散列函数**将键映射到表中一个位置以便快速访问数据。
   - **集合 (Set)**：一种包含**无序且唯一**项的数据结构。

## 算法（Algorithms）

### 算法的定义

算法是一组明确的指令集合，用于完成特定的任务或解决特定的问题。

### 算法四个基本特点

| 特点         | 描述                                                                                   |
|------------|---------------------------------------------------------------------------------------|
| 正确性 (Correctness)     | 能够按照预定功能产生正确的输出。                                                        |
| 易读性 (Readability)     | 逻辑清楚、结构清晰，算法易于阅读、理解、维护。                                            |
| 鲁棒性 (Robustness)     | 对于边界条件输入和非常见输入能正确处理；对非法输入提供适当提示，避免崩溃。              |
| 高效率 (Efficiency)     | 在时间和空间上高效，需要较少的运行时间和存储空间。                                        |

### 算法的时间复杂度(Time Complexity)

- **定义**：衡量算法执行时间随输入数据规模增长的增长率。它是描述算法在处理数据时消耗时间的量化指标。
- **重要性**：时间复杂度帮助我们估计算法处理数据所需的大致时间，尤其是在数据量较大时，时间复杂度成为选择算法的关键因素。

#### 算法时间复杂度影响因素

1. **计算机的硬件性能**：CPU、GPU的核心数和频率。
2. **编程语言和代码质量**：不同编程语言（如Python、C++）及其编译器。
3. **问题和数据的规模**：处理的数据量大小。
4. **算法设计的效率**：算法本身的时间复杂度。

#### 时间复杂度的度量

| 符号类型             | 符号                | 含义                                   | 举例                                         |
|------------------|-------------------|--------------------------------------|--------------------------------------------|
| 大O符号 (上界)      | \(O(f(n))\)           | 描述时间复杂度的最坏情况（上界）                 | 如果算法时间复杂度为 \(O(n^2)\)，则表示最多与 \(n^2\) 成正比 |
| 大Ω符号 (下界)      | \(Ω(f(n))\)           | 描述时间复杂度的最佳情况（下界）                 | 如果算法时间复杂度为 \(Ω(n)\)，则至少为 \(n\)         |
| 大Θ符号 (紧确界)    | \(Θ(f(n))\)           | 同时提供上界和下界，表示算法时间复杂度的确切界限    | 如果算法时间复杂度为 \(Θ(n^2)\)，则精确为 \(n^2\)     |
| 小o符号 (非紧确上界) | \(o(f(n))\)           | 描述非紧确的上界                           | 如果算法时间复杂度为 \(o(n^2)\)，则对于足够大的 \(n\) 速度更快 |
| 小ω符号 (非紧确下界) | \(ω(f(n))\)           | 描述非紧确的下界                           | 如果算法时间复杂度为 \(ω(n)\)，则对于足够大的 \(n\) 速度更慢 |

为了计算这些符号，我们通常会观察代码中的**循环**、**递归调用**以及**其他操作**，根据代码结构来估计算法的时间复杂度。

以下是一些常见的例子：

- 执行 \( n \) 次的 `for` 循环：\( O(n) \)
- 嵌套的 `for` 循环：\( O(n^2) \)
- 类似归并排序的分治算法：\( O(n \log n) \)
- 迭代式斐波那契序列：\( O(n) \)
- 朴素递归斐波那契序列：\( O(2^n) \)

#### 算法在不同情况下的时间复杂度

1. **最好情况时间复杂度 (Best Case Time Complexity)**：
   - **定义**：这是算法在**最理想情况下**能达到的**最高效率**。
   - **例子**：考虑一个在无序数组中查找特定元素的函数。如果要查找的元素恰好是数组的第一个元素，那么算法将立即找到它，对应的时间复杂度是 \(O(1)\)，即常数时间复杂度。

2. **最坏情况时间复杂度 (Worst Case Time Complexity)**：
   - **定义**：这是算法在**最糟糕情况下**的效率，即算法可能遇到的**最长耗时情况**。
   - **例子**：同样的查找函数，如果数组中不存在要查找的元素，算法需要遍历整个数组才能确定元素不在其中。这种情况下，算法的时间复杂度是 \(O(n)\)，其中 n 是数组的长度。

3. **平均情况时间复杂度 (Average Case Time Complexity)**：
   - **定义**：这是算法在所有可能输入的**平均效率**。
   - **计算方式**：通常假设所有可能的输入都等概率出现。计算平均情况复杂度时，需要考虑算法在不同输入下的表现，并进行平均。
   - **例子**：在查找函数的例子中，如果假设要查找的元素在数组中随机分布，那么平均而言，算法需要检查大约一半的数组元素。因此，平均情况时间复杂度也是 \(O(n)\)，但实际上通常会比最坏情况要好一点。

### 算法的空间复杂度(Space Complexity)

- **定义**：衡量算法执行过程中占用存储空间大小随输入数据规模增长的增长率。它反映了算法在运行过程中需要的内存量。
- **重要性**：空间复杂度有助于估计算法执行所需的内存资源。对于存储资源有限的情况，空间复杂度的高低会直接影响算法的可用性。

#### 空间复杂度的度量

空间复杂度不仅关注算法在**处理数据时所需的存储空间**，还包括**算法本身和辅助空间的需求**。下面是对其的深入讲解：

1. **算法执行时的空间消耗**：
   - **组成部分**：
     - **程序代码本身所占空间**：算法实现的代码大小。
     - **存储数据所占空间**：算法处理的数据所需的空间。
     - **中间过程使用的辅助空间**：算法执行过程中额外需要的临时或辅助空间。
   - **重要性**：算法的空间消耗直接影响其执行效率和可用性。在存储资源受限的环境下，空间消耗成为算法设计的关键考虑因素。

2. **算法运行的瓶颈**：
   - 内存与外存的差异可能导致性能瓶颈。
   - **内存空间**：算法运行时直接使用的计算机内存（RAM）。
   - **外存空间**：硬盘等非直接处理数据的存储设备。
   - 当算法所需空间超过内存容量时，可能导致内存溢出或程序崩溃。

3. **空间复杂性的度量**：
   - **定义**：空间复杂性度量了算法占用的辅助空间大小与输入数据规模 \(n\) 之间的关系。
   - **表示方法**：通常使用渐近复杂度来表示，类似于时间复杂性的表示方法。例如，一个算法的空间复杂度为 \(O(n)\)，意味着算法所需的辅助空间与输入规模 \(n\) 成线性关系。

注意在处理大规模数据或在内存受限的环境中，空间复杂性的优化可以显著提高算法的性能和可行性。

### 常用复杂度函数

通常采用以下几种常见的时间复杂度函数。如图所示，当\(n\)逐渐增大时，它们的时间复杂度由左到右依次增大：
\( O(\log n) < O(n) < O(n \log n) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n) \)

![Commonly Used Complexity Functions](Commonly%20Used%20Complexity%20Functions.png)

### 渐进表示法的计算

1. **求和定理**：求和定理用于顺序执行的片段，关注两者中更大的时间复杂度。当有两个程序片段顺序执行，其时间复杂度分别为 \( T_1(n) = O(f(n)) \) 和 \( T_2(n) = O(g(n)) \)，那么整个程序的时间复杂度为 \( T_1(n) + T_2(n) = O(\max(f(n), g(n))) \)。

2. **求积定理**：求积定理用于嵌套执行的片段，将两者时间复杂度相乘。若两个程序片段以嵌套方式执行，时间复杂度分别为 \( T_1(n) = O(f(n)) \) 和 \( T_2(n) = O(g(n)) \)，则整体时间复杂度为 \( T_1(n) \cdot T_2(n) = O(f(n) \cdot g(n)) \)。

### 我们需要学习的算法

1. **排序算法 (Sorting Algorithms)**：
   - **冒泡排序 (Bubble Sort)**：重复地走访数组，比较相邻元素。
   - **快速排序 (Quick Sort)**：选择一个基准元素，重新排列数组，分为两半，递归地应用在两半上。
   - **归并排序 (Merge Sort)**：将数组分为两半，分别排序，然后合并。
   - **AND MORE**

2. **搜索算法 (Search Algorithms)**：
   - **线性搜索 (Linear Search)**：逐一检查数组中的每个元素。
   - **二分搜索 (Binary Search)**：在有序数组中，通过比较中间元素来消除一半的搜索区域。
   - **AND MORE**

3. **图算法 (Graph Algorithms)**：
   - **深度优先搜索 (DFS, Depth-First Search)**：从根开始，尽可能深地搜索每个分支。
   - **广度优先搜索 (BFS, Breadth-First Search)**：从根开始，访问邻近的节点，然后是它们的邻居。
   - **AND MORE**

4. **动态规划 (Dynamic Programming)**：
   - 分解成较小的子问题，然后组合这些子问题的解以解决整个问题。

5. **贪心算法 (Greedy Algorithms)**：
   - 在每一步选择中都采取最优或最佳选择，以期望求得全局最优解。

6. **分治算法 (Divide and Conquer)**：
   - 将问题分解为更小的子问题，分别解决后再组合它们的解。
