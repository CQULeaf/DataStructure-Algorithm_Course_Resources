# 查找

<!-- toc -->
- [查找](#查找)
  - [二分查找（Binary Search）](#二分查找binary-search)
  - [二叉查找树（Binary Search Tree，BST）](#二叉查找树binary-search-treebst)
    - [二叉查找树的操作及实现](#二叉查找树的操作及实现)
      - [1. 二叉查找树 | 查找（递归算法）](#1-二叉查找树--查找递归算法)
      - [2. 二叉查找树 | 查找（非递归算法，二分）](#2-二叉查找树--查找非递归算法二分)
      - [3. 二叉查找树 | 插入](#3-二叉查找树--插入)
      - [4. 二叉查找树 | 删除](#4-二叉查找树--删除)
    - [二叉查找树查找的性能分析](#二叉查找树查找的性能分析)

## 二分查找（Binary Search）

二分查找是一种在**有序序列**中查找特定元素的高效算法。它的核心思想是将搜索范围每次减半。这种方法的时间复杂度是\(O(\log n)\)，其中\(n\)是序列中元素的数量。

**原理**：

- 首先，比较序列中间的元素与目标值。
- 如果中间元素正是目标值，则搜索结束。
- 如果目标值小于中间元素，则在左半部分继续搜索。
- 如果目标值大于中间元素，则在右半部分继续搜索。

## 二叉查找树（Binary Search Tree，BST）

二叉查找树是一种特殊的二叉树，它为二分查找提供了数据结构基础。

**特性**：

- 如果结点的左子树非空，则左子树上所有结点的数据小于该结点的数据。
- 如果结点的右子树非空，则右子树上所有结点的数据大于该结点的数据。
- 左、右子树本身也是二叉查找树。

**操作**：

- **查找**：从根结点开始，如果目标数据小于当前结点的数据，继续在左子树查找；如果大于，则在右子树查找。查找的时间复杂度平均是\(O(\log n)\)。
- **插入**：从根结点开始，根据插入值与当前结点的比较结果决定是向左子树还是右子树移动，直到找到合适的插入位置。最坏情况下，插入操作的时间复杂度可能达到\(O(n)\)。
- **删除**：删除操作比较复杂，可能需要考虑多种情况。最坏情况下，删除操作的时间复杂度也是\(O(n)\)。

**应用局限性**：

- 当树变得不平衡时，即某一侧特别长而另一侧较短，二叉查找树的效率会降低，接近线性查找。
- 在进行大量插入或删除操作时，二叉查找树可能需要重新平衡。

为了解决这些局限性，后来又发展了一些平衡的二叉树结构，例如AVL树和红黑树。这些结构可以在插入和删除操作后自动保持或恢复平衡，从而保证操作的高效性。

### 二叉查找树的操作及实现

#### 1. 二叉查找树 | 查找（递归算法）

**步骤**：

1. 检查当前节点是否为空或是否为查找的值，如果是，则返回当前节点。
2. 如果查找的值小于当前节点的值，递归地在左子树中查找。
3. 如果查找的值大于当前节点的值，递归地在右子树中查找。

#### 2. 二叉查找树 | 查找（非递归算法，二分）

**步骤**：

1. 从根节点开始，循环进行搜索。
2. 如果当前节点为空，说明没有找到，返回null。
3. 比较当前节点的值与查找的值。
4. 如果查找的值小于当前节点的值，移动到左子节点。
5. 如果查找的值大于当前节点的值，移动到右子节点。
6. 如果找到了目标值，返回当前节点。

#### 3. 二叉查找树 | 插入

**步骤**：

1. 如果根节点为空，新的节点将成为根节点。
2. 从根节点开始，比较插入的值与当前节点的值。
3. 如果插入的值小于当前节点的值，且左子节点为空，则插入左子节点，否则继续在左子树中递归搜索插入位置。
4. 如果插入的值大于当前节点的值，且右子节点为空，则插入右子节点，否则继续在右子树中递归搜索插入位置。

#### 4. 二叉查找树 | 删除

**步骤**：

1. 被删除的节点是叶子节点：
对于叶子节点，我们只需要将其父节点指向它的指针设置为`nullptr`即可。

1. 被删除的节点只有一个子节点（左子节点或右子节点）：
对于只有一个子节点的节点，我们需要将这个子节点提升到被删除节点的位置。具体来说，我们需要将被删除节点的父节点的相应指针指向被删除节点的子节点。

1. 被删除的节点既有左子节点，也有右子节点：
这是最复杂的情况。通常的处理方法是找到被删除节点的右子树中的最小节点（即右子树的最左边的节点），将其提升到被删除节点的位置，同时处理这个最小节点原来的位置（因为它已经被移动了）。这个最小节点是被删除节点的中序后继节点。***选择前驱（左子树中的最大节点）其实也可以***

***以上所有BST基本操作的代码实现见`Basic Operation of BST.cpp`文件。***

### 二叉查找树查找的性能分析

当我们讨论二叉排序树（Binary Search Tree, BST）的查找性能时，通常会用平均搜索长度（Average Search Length, ASL）来度量。ASL 是对树中节点进行查找操作所需比较次数的平均值。

对于一棵特定的BST，ASL的计算涉及以下几个因素：

1. **树的形状**：树的高度和结构直接影响查找性能。在最理想的情况下，树是完全平衡的，每个节点都有两个子节点（除了叶子节点），这时查找性能最好，ASL接近于树的高度的对数（即 \( \log_2 n \)，其中 \( n \) 是节点的数量）。然而，在最坏的情况下，树可能会退化成一个链表，这时ASL将接近于 \( n \)。

2. **关键字的分布**：关键字在树中的分布也会影响ASL。如果某些关键字被查找的频率更高，那么这些关键字在树的位置会更加影响ASL。

3. **查找顺序**：由于查找顺序的不同，即使是相同的一组关键字，也可能构造出形态各异的多棵BST。每棵树的ASL可能会有很大差异。

要精确计算一棵特定BST的ASL，我们需要考虑树中每个节点的深度（从根到该节点的路径长度），ASL是所有节点的深度之和除以节点总数，其计算公式为：

\[ \text{ASL} = \frac{\sum_{i=1}^{n} \text{深度}(节点_i)}{n} \]

其中 \( n \) 是树中节点的总数，\(\text{深度}(节点_i)\) 是第 \( i \) 个节点的深度。

在实际应用中，为了获得更好的查找性能，我们常常会使用各种平衡树（如AVL树、红黑树）来代替普通的BST，因为平衡树能够在插入和删除操作后自动保持树的平衡，从而保证查找操作的效率。
