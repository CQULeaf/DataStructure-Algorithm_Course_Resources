<!-- TOC -->

# 排序算法

- [排序算法](#排序算法)
  - [排序引入：了解基本概念](#排序引入了解基本概念)
    - [排序的稳定性（Sorting Stability）](#排序的稳定性sorting-stability)
    - [排序的分类](#排序的分类)
    - [排序的应用](#排序的应用)
  - [1. 插入排序（Insertion Sort）](#1-插入排序insertion-sort)
    - [1.1 直接插入排序（Straight Insertion Sort）](#11-直接插入排序straight-insertion-sort)
      - [直接插入排序的原理](#直接插入排序的原理)
      - [直接插入排序的性能分析](#直接插入排序的性能分析)
      - [直接插入排序的代码实现](#直接插入排序的代码实现)
    - [1.2 折半插入排序（Binary Insertion Sort）](#12-折半插入排序binary-insertion-sort)
      - [折半插入排序的原理](#折半插入排序的原理)
      - [折半插入排序的性能分析](#折半插入排序的性能分析)
      - [折半插入排序的代码实现](#折半插入排序的代码实现)
    - [1.3 希尔排序（Shell Sort）](#13-希尔排序shell-sort)
      - [希尔排序的原理](#希尔排序的原理)
      - [希尔排序的性能分析](#希尔排序的性能分析)
      - [希尔排序的代码实现](#希尔排序的代码实现)
    - [三种插入排序对比](#三种插入排序对比)
  - [2. 选择排序（Selection Sort）](#2-选择排序selection-sort)
    - [2.1 简单选择排序（Simple Selection Sort）](#21-简单选择排序simple-selection-sort)
      - [简单选择排序的原理](#简单选择排序的原理)
      - [简单选择排序的性能分析](#简单选择排序的性能分析)
      - [简单选择排序的代码实现](#简单选择排序的代码实现)
    - [2.2 煎饼排序（Pancake Sort）](#22-煎饼排序pancake-sort)
      - [煎饼排序的原理](#煎饼排序的原理)
      - [煎饼排序的性能分析](#煎饼排序的性能分析)
      - [煎饼排序的代码实现](#煎饼排序的代码实现)
    - [2.3 堆排序（Heap Sort）](#23-堆排序heap-sort)
      - [堆排序的原理](#堆排序的原理)
      - [堆排序的性能分析](#堆排序的性能分析)
      - [堆排序的代码实现](#堆排序的代码实现)
    - [三种选择排序对比](#三种选择排序对比)
  - [3. 交换排序](#3-交换排序)
    - [3.1 冒泡排序](#31-冒泡排序)

## 排序引入：了解基本概念

### 排序的稳定性（Sorting Stability）

指对于序列中关键字值相等的节点，在排序后是否能保持原有的相对顺序。稳定性在某些应用中非常重要，因为它保证了排序过程不会打乱数据中的固有关系。

- **稳定的排序算法**：插入排序（Insertion Sort）、冒泡排序（Bubble Sort）、归并排序（Merge Sort）。
- **不稳定的排序算法**：选择排序（Selection Sort）、快速排序（Quick Sort）、堆排序（Heap Sort）。

### 排序的分类

1. **内部排序与外部排序**：
   - **内部排序**（Internal Sorting）：所有数据操作都在内存中进行。
   - **外部排序**（External Sorting）：处理的数据量很大，需要借助外部存储（如硬盘）。

2. **比较排序与分配排序**：
   - **比较排序**（Comparative Sorting）：通过比较元素间的关键字来确定顺序。例如：插入排序、冒泡排序、选择排序、快速排序、归并排序、希尔排序（Shell Sort）、堆排序。
   - **分配排序**（Distribution Sorting）：通过分配和收集来排序元素。例如：基数排序（Radix Sort）、桶排序（Bucket Sort）。

3. **难易程度**：
   - **基本排序**：如插入排序、冒泡排序、选择排序。
   - **高级排序**：如快速排序、归并排序、堆排序、基数排序。

### 排序的应用

1. **最近数据对（Closest Pair）**：在排序后的序列中，差值最小的两个数据相邻，便于快速查找。
2. **数据的唯一性（Element Uniqueness）**：通过排序后的序列来判断数据是否有重复，相邻元素比较可以轻松发现重复。
3. **统计数据出现次数（Frequency Distribution – Mode）**：排序后，相同的数据会连续出现，方便统计每种数据的出现次数。
4. **中位数与选择（Median and Selection）**：排序后，可以直接访问第k个位置的元素来得到第k小的数据。

## 1. 插入排序（Insertion Sort）

### 1.1 直接插入排序（Straight Insertion Sort）

#### 直接插入排序的原理

直接插入排序通过构建有序序列，对于未排序数据，在已排序序列中**从后向前**扫描，找到相应位置并插入。具体步骤如下：

1. **开始时**：将数组的第一个元素视为已排序的序列，其余为未排序序列。
2. **从第二个元素开始**：取出未排序序列中的第一个元素，即当前元素。
3. **比较和插入**：将当前元素与已排序序列中的元素从后向前依次比较。如果已排序元素大于当前元素，则已排序元素向后移动一位，为当前元素腾出空间。
4. **插入元素**：重复上述比较过程，直到找到一个已排序元素小于或等于当前元素的位置，将当前元素插入此位置。
5. **重复步骤 2-4**：对所有未排序的元素重复以上步骤。

![Straight Insertion Sort](images/Straight%20Insertion%20Sort.png "对关键词序列升序排序")

#### 直接插入排序的性能分析

- **时间复杂度**：
  - 平均情况：\(O(n^2)\)
  - 最坏情况：\(O(n^2)\)（当输入序列完全逆序时）

- **空间复杂度**：
  - \(O(1)\)，直接插入排序是原地排序算法。

- **稳定性**：
  - 稳定。插入排序不改变相同元素的相对顺序。

#### 直接插入排序的代码实现

见`Straight Insertion Sort.cpp`文件。

### 1.2 折半插入排序（Binary Insertion Sort）

#### 折半插入排序的原理

折半插入排序是直接插入排序的一个变体，主要改进在于查找插入位置的过程。它通过二分查找（折半查找）来减少比较次数，尽管在插入时仍需要移动元素。

**算法步骤**：

1. **初始状态**：将数组的第一个元素视为已排序序列，其余为未排序序列。
2. **对未排序的每个元素**：对于未排序序列中的每一个元素（从第二个元素开始），进行以下操作：
   - 使用二分查找在已排序序列中找到该元素的正确位置。
   - 将已排序序列中的元素向后移动，以便为新元素腾出空间。
   - 将该元素插入到找到的位置。
3. **重复**：重复步骤 2，直到所有元素都被排序。

#### 折半插入排序的性能分析

- **时间复杂度**：
  - 平均情况：\(O(n^2)\)
  - 最坏情况：\(O(n^2)\)

  尽管折半插入排序减少了比较次数，但元素的移动次数依然是\(O(n^2)\)。

- **空间复杂度**：
  - \(O(1)\)，原地排序算法。

- **稳定性**：
  - 稳定。折半插入排序不改变相同元素的相对顺序。

#### 折半插入排序的代码实现

见`Binary Insertion Sort.cpp`文件。

### 1.3 希尔排序（Shell Sort）

#### 希尔排序的原理

希尔排序，也被称为“缩小增量排序”，是直接插入排序的一种高效改进版本。它通过将原始数据分割成多个子序列，分别进行直接插入排序，逐步达到整个序列的排序。

![Shell Sort](images/Shell%20Sort.png "增量分别为8,4,2,1")

**算法步骤**：

1. **选择增量序列**：首先选择一个增量序列 \(t_1, t_2, ..., t_k\)，其中 \(t_k=1\)（通常使用序列的长度逐步减半作为增量，直至为1）。
2. **按增量序列分组**：根据当前增量 \(t_i\)，将序列分为若干组，每组包含间隔为 \(t_i\) 的元素。
3. **分组内排序**：对每个分组应用直接插入排序。
4. **减小增量重复**：取下一个增量 \(t_{i-1}\)，重复步骤 2 和 3，直到增量为 1。

#### 希尔排序的性能分析

- **时间复杂度**：
  - 平均情况：依赖于增量序列，一般优于 \(O(n^2)\)，但不同的增量序列有不同的性能。
  - 最坏情况：取决于增量序列，最差可达 \(O(n^2)\)。

- **空间复杂度**：
  - \(O(1)\)，希尔排序是原地排序算法。

- **稳定性**：
  - 不稳定。由于增量的存在，可能会导致相同元素的相对位置发生变化。

#### 希尔排序的代码实现

见`Shell Sort.cpp`文件。

### 三种插入排序对比

| 插入排序类型         | 特点                                                         | 使用情况                           |
|-----------------|------------------------------------------------------------|-------------------------------|
| 直接插入排序 | 简单且易实现。                                   | 小数据集，基本有序数据。             |
| 折半插入排序   | 在直接插入排序基础上改进查找过程，使用二分查找定位插入位置，减少比较次数，但移动次数不变。 | 小数据集，需要减少比较次数的场合。       |
| 希尔排序  | 通过设置不同的增量，将数组分为多个子序列进行排序。                  | 大数据集，需要提高效率的场合。           |

## 2. 选择排序（Selection Sort）

### 2.1 简单选择排序（Simple Selection Sort）

#### 简单选择排序的原理

简单选择排序的基本思想是在每一轮中选择最小（或最大）的元素，将其放置在序列的起始位置。

![Simple Selection Sort](images/Simple%20Selection%20Sort.png)

**算法步骤**：

1. **初始状态**：整个数组视为未排序。
2. **查找最小元素**：在未排序的数组中找到最小（或最大）的元素。
3. **放置元素**：将找到的最小（或最大）元素和未排序序列的首元素交换。
4. **重复步骤 2-3**：对剩余的未排序序列重复上述过程，直到整个数组排序完成。

#### 简单选择排序的性能分析

- **时间复杂度**：
  - 平均情况：\(O(n^2)\)
  - 最坏情况：\(O(n^2)\)

  无论原始数据如何，选择排序的比较次数总是固定的。

- **空间复杂度**：
  - \(O(1)\)，原地排序算法。

- **稳定性**：
  - 不稳定。选择排序可能会改变相同元素的相对顺序。

#### 简单选择排序的代码实现

见`Simple Selection Sort.cpp`文件。

### 2.2 煎饼排序（Pancake Sort）

#### 煎饼排序的原理

煎饼排序的特别之处在于它的操作限制：唯一允许的操作是“翻转”数组的前若干个元素。

[LeetCode 969](https://leetcode.com/problems/pancake-sorting)

```cpp
class Solution {
public:
    vector<int> pancakeSort(vector<int>& arr) {
        vector<int> result;
        for (int size = arr.size(); size > 0; --size) {
            int max_idx = max_element(arr.begin(), arr.begin() + size) - arr.begin();
            if (max_idx == size - 1) continue; // 如果最大元素已经在正确位置，则不需要翻转
            if (max_idx > 0) {
                result.push_back(max_idx + 1); // 记录翻转大小
                reverse(arr.begin(), arr.begin() + max_idx + 1); // 翻转最大元素到首位
            }
            result.push_back(size); // 记录翻转大小
            reverse(arr.begin(), arr.begin() + size); // 翻转最大元素到正确位置
        }
        return result;
    }
};

```

煎饼排序的翻转次数：

- **最大翻转次数**：\( 2n - 3 \)
  - 每个元素（除了第一个和最后一个元素外）最多需要两次翻转来放置到其正确位置。
    - 第一个元素最多需要一次翻转（如果它不在正确位置上）。（次数 = 1）
    - 最后一个元素不需要翻转，因为当其他所有元素都已经被正确排序时，最后一个元素也会自然地处于正确的位置。（次数 = 0）
    - 其他 \( n - 2 \) 个元素每个最多需要两次翻转。（次数 = \(2( n - 2 \))）
- **最小翻转次数**：0 (序列已经完全排序)

**算法步骤**：

1. **找到最大元素**：在未排序的数组中找到最大元素。
2. **翻转到首位**：如果最大元素不在首位，通过一次翻转操作，将其翻转到数组的首位。
3. **翻转到末尾**：再通过一次翻转操作，将首位的最大元素翻转到它在排序后应处的位置，即未排序部分的末尾。
4. **缩小排序范围**：缩小未排序数组的范围，排除已放置在正确位置上的最大元素。
5. **重复以上步骤**：重复以上步骤，直到所有元素都被排序。

#### 煎饼排序的性能分析

- **时间复杂度**：最坏情况下的时间复杂度为 \(O(n^2)\)，其中 \(n\) 是数组的长度。每次找到最大元素和进行翻转都需要线性时间。
- **空间复杂度**：\(O(1)\)，煎饼排序是原地排序算法。
- **稳定性**：不稳定。煎饼排序在翻转元素时可能会改变相同元素的相对顺序。

#### 煎饼排序的代码实现

见`Pancake Sort.cpp`文件。

### 2.3 堆排序（Heap Sort）

#### 堆排序的原理

堆排序是一种基于比较的排序算法，它使用了一种称为堆的特殊树结构。在堆排序中，我们通常使用最大堆来排序，使数组以升序排列。

**算法步骤**：

1. **建立最大堆**：将给定的无序数组构造出一个最大堆。最大堆是一种完全二叉树，其中每个节点的值都大于或等于其子节点的值。
2. **堆顶元素与末尾元素交换**：在最大堆中，堆顶元素是最大的。将它与堆中的最后一个元素交换，这样最大元素就被放到了数组的末尾。
3. **重新调整堆**：交换后，除了最后一个元素外，剩余元素可能不再满足最大堆的性质。因此，需要重新调整堆。
4. **重复以上步骤**：重复步骤 2 和 3，每次减少堆的大小，直到堆的大小减至 1。

#### 堆排序的性能分析

- **时间复杂度**：
  - 平均情况：\(O(n\log n)\)
  - 最坏情况：\(O(n\log n)\)

- **空间复杂度**：
  - \(O(1)\)，堆排序是原地排序算法。

- **稳定性**：
  - 不稳定。堆排序会将堆顶元素与数组末尾元素进行交换。

#### 堆排序的代码实现

见`Heap Sort.cpp`文件。

### 三种选择排序对比

| 选择排序类型 | 特点                                                         | 使用情况                           |
|---------------------|------------------------------------------------------------|-------------------------------|
| 简单选择排序| 直观简单，每轮选择最小（或最大）元素放置到正确位置。时间复杂度较高。 | 小数据集，对稳定性要求不高的场景       |
| 煎饼排序     | 有趣且独特，只使用翻转操作。不适合大规模数据，通常更多作为算法问题而非实际应用。 | 教学、算法展示，适用于小数据集或算法竞赛 |
| 堆排序        | 基于堆这种数据结构，时间复杂度较低，适合大数据，但不稳定。   | 大数据集，对时间效率要求较高的场景       |

## 3. 交换排序

### 3.1 冒泡排序

