<!-- TOC -->

# 排序算法

- [排序算法](#排序算法)
  - [排序引入：了解基本概念](#排序引入了解基本概念)
    - [排序的稳定性（Sorting Stability）](#排序的稳定性sorting-stability)
    - [排序的分类](#排序的分类)
    - [排序的应用](#排序的应用)
  - [1. 插入排序（Insertion Sort）](#1-插入排序insertion-sort)
    - [1.1 直接插入排序（Straight Insertion Sort）](#11-直接插入排序straight-insertion-sort)
      - [直接插入排序的原理](#直接插入排序的原理)
      - [直接插入排序的性能分析](#直接插入排序的性能分析)
      - [直接插入排序的代码实现](#直接插入排序的代码实现)
    - [1.2 折半插入排序（Binary Insertion Sort）](#12-折半插入排序binary-insertion-sort)
      - [折半插入排序的原理](#折半插入排序的原理)
      - [折半插入排序的性能分析](#折半插入排序的性能分析)
      - [折半插入排序的代码实现](#折半插入排序的代码实现)
    - [1.3 希尔排序（Shell Sort）](#13-希尔排序shell-sort)
      - [希尔排序的原理](#希尔排序的原理)
      - [希尔排序的性能分析](#希尔排序的性能分析)
      - [希尔排序的代码实现](#希尔排序的代码实现)
    - [三种插入排序对比](#三种插入排序对比)
  - [2. 选择排序（Selection Sort）](#2-选择排序selection-sort)
    - [2.1 简单选择排序（Simple Selection Sort）](#21-简单选择排序simple-selection-sort)
      - [简单选择排序的原理](#简单选择排序的原理)
      - [简单选择排序的性能分析](#简单选择排序的性能分析)
      - [简单选择排序的代码实现](#简单选择排序的代码实现)
    - [2.2 煎饼排序（Pancake Sort）](#22-煎饼排序pancake-sort)
      - [煎饼排序的原理](#煎饼排序的原理)
      - [煎饼排序的性能分析](#煎饼排序的性能分析)
      - [煎饼排序的代码实现](#煎饼排序的代码实现)
    - [2.3 堆排序（Heap Sort）](#23-堆排序heap-sort)
      - [堆排序的原理](#堆排序的原理)
      - [堆排序的性能分析](#堆排序的性能分析)
      - [堆排序的代码实现](#堆排序的代码实现)
    - [三种选择排序对比](#三种选择排序对比)
  - [3. 交换排序（Exchange Sort）](#3-交换排序exchange-sort)
    - [3.1 冒泡排序（Bubble Sort）](#31-冒泡排序bubble-sort)
      - [冒泡排序的原理](#冒泡排序的原理)
      - [冒泡排序的性能分析](#冒泡排序的性能分析)
      - [冒泡排序的代码实现](#冒泡排序的代码实现)
    - [3.2 快速排序（Quick Sort）](#32-快速排序quick-sort)
      - [快速排序的原理](#快速排序的原理)
      - [快速排序的性能分析](#快速排序的性能分析)
      - [快速排序的代码实现](#快速排序的代码实现)
      - [快速排序的优化（三数取中法）](#快速排序的优化三数取中法)
  - [4. 归并排序（Merge Sort）](#4-归并排序merge-sort)
    - [4.1 二路归并（Two-Way Merge Sort）](#41-二路归并two-way-merge-sort)
      - [二路归并排序的原理](#二路归并排序的原理)
      - [二路归并排序的性能分析](#二路归并排序的性能分析)
      - [二路归并排序的代码实现](#二路归并排序的代码实现)
    - [4.2 归并排序（Merge Sort）](#42-归并排序merge-sort)

## 排序引入：了解基本概念

### 排序的稳定性（Sorting Stability）

指对于序列中关键字值相等的节点，在排序后是否能保持原有的相对顺序。稳定性在某些应用中非常重要，因为它保证了排序过程不会打乱数据中的固有关系。

- **稳定的排序算法**：插入排序（Insertion Sort）、冒泡排序（Bubble Sort）、归并排序（Merge Sort）。
- **不稳定的排序算法**：选择排序（Selection Sort）、快速排序（Quick Sort）、堆排序（Heap Sort）。

### 排序的分类

1. **内部排序与外部排序**：
   - **内部排序**（Internal Sorting）：所有数据操作都在内存中进行。
   - **外部排序**（External Sorting）：处理的数据量很大，需要借助外部存储（如硬盘）。

2. **比较排序与分配排序**：
   - **比较排序**（Comparative Sorting）：通过比较元素间的关键字来确定顺序。例如：插入排序、冒泡排序、选择排序、快速排序、归并排序、希尔排序（Shell Sort）、堆排序。
   - **分配排序**（Distribution Sorting）：通过分配和收集来排序元素。例如：基数排序（Radix Sort）、桶排序（Bucket Sort）。

3. **难易程度**：
   - **基本排序**：如插入排序、冒泡排序、选择排序。
   - **高级排序**：如快速排序、归并排序、堆排序、基数排序。

### 排序的应用

1. **最近数据对（Closest Pair）**：在排序后的序列中，差值最小的两个数据相邻，便于快速查找。
2. **数据的唯一性（Element Uniqueness）**：通过排序后的序列来判断数据是否有重复，相邻元素比较可以轻松发现重复。
3. **统计数据出现次数（Frequency Distribution – Mode）**：排序后，相同的数据会连续出现，方便统计每种数据的出现次数。
4. **中位数与选择（Median and Selection）**：排序后，可以直接访问第k个位置的元素来得到第k小的数据。

## 1. 插入排序（Insertion Sort）

### 1.1 直接插入排序（Straight Insertion Sort）

#### 直接插入排序的原理

直接插入排序通过构建有序序列，对于未排序数据，在已排序序列中**从后向前**扫描，找到相应位置并插入。具体步骤如下：

1. **开始时**：将数组的第一个元素视为已排序的序列，其余为未排序序列。
2. **从第二个元素开始**：取出未排序序列中的第一个元素，即当前元素。
3. **比较和插入**：将当前元素与已排序序列中的元素从后向前依次比较。如果已排序元素大于当前元素，则已排序元素向后移动一位，为当前元素腾出空间。
4. **插入元素**：重复上述比较过程，直到找到一个已排序元素小于或等于当前元素的位置，将当前元素插入此位置。
5. **重复步骤 2-4**：对所有未排序的元素重复以上步骤。

![Straight Insertion Sort](images/Straight%20Insertion%20Sort.png "对关键词序列升序排序")

#### 直接插入排序的性能分析

- **时间复杂度**：
  - 平均情况：\(O(n^2)\)
  - 最坏情况：\(O(n^2)\)（当输入序列完全逆序时）

- **空间复杂度**：
  - \(O(1)\)，直接插入排序是原地排序算法。

- **稳定性**：
  - 稳定。插入排序不改变相同元素的相对顺序。

#### 直接插入排序的代码实现

见`Straight Insertion Sort.cpp`文件。

### 1.2 折半插入排序（Binary Insertion Sort）

#### 折半插入排序的原理

折半插入排序是直接插入排序的一个变体，主要改进在于查找插入位置的过程。它通过二分查找（折半查找）来减少比较次数，尽管在插入时仍需要移动元素。

**算法步骤**：

1. **初始状态**：将数组的第一个元素视为已排序序列，其余为未排序序列。
2. **对未排序的每个元素**：对于未排序序列中的每一个元素（从第二个元素开始），进行以下操作：
   - 使用二分查找在已排序序列中找到该元素的正确位置。
   - 将已排序序列中的元素向后移动，以便为新元素腾出空间。
   - 将该元素插入到找到的位置。
3. **重复**：重复步骤 2，直到所有元素都被排序。

#### 折半插入排序的性能分析

- **时间复杂度**：
  - 平均情况：\(O(n^2)\)
  - 最坏情况：\(O(n^2)\)

  尽管折半插入排序减少了比较次数，但元素的移动次数依然是\(O(n^2)\)。

- **空间复杂度**：
  - \(O(1)\)，原地排序算法。

- **稳定性**：
  - 稳定。折半插入排序不改变相同元素的相对顺序。

#### 折半插入排序的代码实现

见`Binary Insertion Sort.cpp`文件。

### 1.3 希尔排序（Shell Sort）

#### 希尔排序的原理

希尔排序，也被称为“缩小增量排序”，是直接插入排序的一种高效改进版本。它通过将原始数据分割成多个子序列，分别进行直接插入排序，逐步达到整个序列的排序。

![Shell Sort](images/Shell%20Sort.png "增量分别为8,4,2,1")

**算法步骤**：

1. **选择增量序列**：首先选择一个增量序列 \(t_1, t_2, ..., t_k\)，其中 \(t_k=1\)（通常使用序列的长度逐步减半作为增量，直至为1）。
2. **按增量序列分组**：根据当前增量 \(t_i\)，将序列分为若干组，每组包含间隔为 \(t_i\) 的元素。
3. **分组内排序**：对每个分组应用直接插入排序。
4. **减小增量重复**：取下一个增量 \(t_{i-1}\)，重复步骤 2 和 3，直到增量为 1。

#### 希尔排序的性能分析

- **时间复杂度**：
  - 平均情况：依赖于增量序列，一般优于 \(O(n^2)\)，但不同的增量序列有不同的性能。
  - 最坏情况：取决于增量序列，最差可达 \(O(n^2)\)。

- **空间复杂度**：
  - \(O(1)\)，希尔排序是原地排序算法。

- **稳定性**：
  - 不稳定。由于增量的存在，可能会导致相同元素的相对位置发生变化。

#### 希尔排序的代码实现

见`Shell Sort.cpp`文件。

### 三种插入排序对比

| 插入排序类型         | 特点                                                         | 使用情况                           |
|-----------------|------------------------------------------------------------|-------------------------------|
| 直接插入排序 | 简单且易实现。                                   | 小数据集，基本有序数据。             |
| 折半插入排序   | 在直接插入排序基础上改进查找过程，使用二分查找定位插入位置，减少比较次数，但移动次数不变。 | 小数据集，需要减少比较次数的场合。       |
| 希尔排序  | 通过设置不同的增量，将数组分为多个子序列进行排序。                  | 大数据集，需要提高效率的场合。           |

## 2. 选择排序（Selection Sort）

### 2.1 简单选择排序（Simple Selection Sort）

#### 简单选择排序的原理

简单选择排序的基本思想是在每一轮中选择最小（或最大）的元素，将其放置在序列的起始位置。

![Simple Selection Sort](images/Simple%20Selection%20Sort.png)

**算法步骤**：

1. **初始状态**：整个数组视为未排序。
2. **查找最小元素**：在未排序的数组中找到最小（或最大）的元素。
3. **放置元素**：将找到的最小（或最大）元素和未排序序列的首元素交换。
4. **重复步骤 2-3**：对剩余的未排序序列重复上述过程，直到整个数组排序完成。

#### 简单选择排序的性能分析

- **时间复杂度**：
  - 平均情况：\(O(n^2)\)
  - 最坏情况：\(O(n^2)\)

  无论原始数据如何，选择排序的比较次数总是固定的。

- **空间复杂度**：
  - \(O(1)\)，原地排序算法。

- **稳定性**：
  - 不稳定。选择排序可能会改变相同元素的相对顺序。

#### 简单选择排序的代码实现

见`Simple Selection Sort.cpp`文件。

### 2.2 煎饼排序（Pancake Sort）

#### 煎饼排序的原理

煎饼排序的特别之处在于它的操作限制：唯一允许的操作是“翻转”数组的前若干个元素。

[LeetCode 969](https://leetcode.com/problems/pancake-sorting)

```cpp
class Solution {
public:
    vector<int> pancakeSort(vector<int>& arr) {
        vector<int> result;
        for (int size = arr.size(); size > 0; --size) {
            int max_idx = max_element(arr.begin(), arr.begin() + size) - arr.begin();
            if (max_idx == size - 1) continue; // 如果最大元素已经在正确位置，则不需要翻转
            if (max_idx > 0) {
                result.push_back(max_idx + 1); // 记录翻转大小
                reverse(arr.begin(), arr.begin() + max_idx + 1); // 翻转最大元素到首位
            }
            result.push_back(size); // 记录翻转大小
            reverse(arr.begin(), arr.begin() + size); // 翻转最大元素到正确位置
        }
        return result;
    }
};

```

煎饼排序的翻转次数：

- **最大翻转次数**：\( 2n - 3 \)
  - 每个元素（除了第一个和最后一个元素外）最多需要两次翻转来放置到其正确位置。
    - 第一个元素最多需要一次翻转（如果它不在正确位置上）。（次数 = 1）
    - 最后一个元素不需要翻转，因为当其他所有元素都已经被正确排序时，最后一个元素也会自然地处于正确的位置。（次数 = 0）
    - 其他 \( n - 2 \) 个元素每个最多需要两次翻转。（次数 = \(2( n - 2 \))）
- **最小翻转次数**：0 (序列已经完全排序)

**算法步骤**：

1. **找到最大元素**：在未排序的数组中找到最大元素。
2. **翻转到首位**：如果最大元素不在首位，通过一次翻转操作，将其翻转到数组的首位。
3. **翻转到末尾**：再通过一次翻转操作，将首位的最大元素翻转到它在排序后应处的位置，即未排序部分的末尾。
4. **缩小排序范围**：缩小未排序数组的范围，排除已放置在正确位置上的最大元素。
5. **重复以上步骤**：重复以上步骤，直到所有元素都被排序。

#### 煎饼排序的性能分析

- **时间复杂度**：最坏情况下的时间复杂度为 \(O(n^2)\)，其中 \(n\) 是数组的长度。每次找到最大元素和进行翻转都需要线性时间。
- **空间复杂度**：\(O(1)\)，煎饼排序是原地排序算法。
- **稳定性**：不稳定。煎饼排序在翻转元素时可能会改变相同元素的相对顺序。

#### 煎饼排序的代码实现

见`Pancake Sort.cpp`文件。

### 2.3 堆排序（Heap Sort）

#### 堆排序的原理

堆排序是一种基于比较的排序算法，它使用了一种称为堆的特殊树结构。在堆排序中，我们通常使用最大堆来排序，使数组以升序排列。

**算法步骤**：

1. **建立最大堆**：将给定的无序数组构造出一个最大堆。最大堆是一种完全二叉树，其中每个节点的值都大于或等于其子节点的值。
2. **堆顶元素与末尾元素交换**：在最大堆中，堆顶元素是最大的。将它与堆中的最后一个元素交换，这样最大元素就被放到了数组的末尾。
3. **重新调整堆**：交换后，除了最后一个元素外，剩余元素可能不再满足最大堆的性质。因此，需要重新调整堆。
4. **重复以上步骤**：重复步骤 2 和 3，每次减少堆的大小，直到堆的大小减至 1。

#### 堆排序的性能分析

- **时间复杂度**：
  - 平均情况：\(O(n\log n)\)
  - 最坏情况：\(O(n\log n)\)

- **空间复杂度**：
  - \(O(1)\)，堆排序是原地排序算法。

- **稳定性**：
  - 不稳定。堆排序会将堆顶元素与数组末尾元素进行交换。

#### 堆排序的代码实现

见`Heap Sort.cpp`文件。

### 三种选择排序对比

| 选择排序类型 | 特点                                                         | 使用情况                           |
|---------------------|------------------------------------------------------------|-------------------------------|
| 简单选择排序| 直观简单，每轮选择最小（或最大）元素放置到正确位置。时间复杂度较高。 | 小数据集，对稳定性要求不高的场景       |
| 煎饼排序     | 有趣且独特，只使用翻转操作。不适合大规模数据，通常更多作为算法问题而非实际应用。 | 教学、算法展示，适用于小数据集或算法竞赛 |
| 堆排序        | 基于堆这种数据结构，时间复杂度较低，适合大数据，但不稳定。   | 大数据集，对时间效率要求较高的场景       |

## 3. 交换排序（Exchange Sort）

### 3.1 冒泡排序（Bubble Sort）

#### 冒泡排序的原理

冒泡排序基本思想是通过重复地遍历待排序的序列，比较相邻元素，如果它们的顺序错误就交换它们。这个过程像气泡一样，较小（或较大）的元素逐渐“浮”到序列的顶端。

![Bubble Sort](images/Bubble%20Sort.jpg)

**算法步骤**：

1. **比较相邻元素**：从序列的开始处开始，比较每一对相邻元素。如果它们的顺序错误（如第一个比第二个大），则交换它们。
2. **完成一轮遍历**：对每一对相邻元素执行步骤 1，直到序列的末尾。这样，最大的元素会被“冒泡”到序列的末尾。
3. **重复操作**：重复步骤 1 和 2，每次遍历时忽略已经排序好的末尾元素。
4. **完成排序**：当没有更多元素需要交换时，序列排序完成。

#### 冒泡排序的性能分析

- **时间复杂度**：
  - 平均情况：\(O(n^2)\)
  - 最坏情况：\(O(n^2)\)
  - 最好情况：\(O(n)\)（当输入序列已经是排好序的）

- **空间复杂度**：
  - \(O(1)\)，冒泡排序是原地排序算法。

- **稳定性**：
  - 稳定。

#### 冒泡排序的代码实现

见`Bubble Sort.cpp`文件。

### 3.2 快速排序（Quick Sort）

#### 快速排序的原理

使用分治法（Divide and Conquer）来递归地排序数组。

**算法步骤**：

1. **选择基准值（Pivot）**：从数组中选择一个元素作为基准值，通常选择**第一个**元素或**随机一个**元素。
2. **分区（Partitioning）**：重新排列数组，使得所有比基准值小的元素都移动到基准值的左边，所有比基准值大的元素都移动到基准值的右边。分区操作结束后，基准值位于其最终位置。
3. **递归排序子数组**：递归地将左侧子数组和右侧子数组进行快速排序。
4. **终止条件**：当子数组的大小足够小或为零时，递归结束。

#### 快速排序的性能分析

- **时间复杂度**：
  - 最佳情况：\(O(n\log n)\)，当分区操作每次都能均匀划分数组时。
  - 平均情况：\(O(n\log n)\)
  - 最坏情况：\(O(n^2)\)，当分区操作产生的子数组极度不平衡时，例如在已排序或逆序数组上。

- **空间复杂度**：
  - \(O(\log n)\)，由于递归调用的栈空间。

- **稳定性**：
  - 不稳定。快速排序在分区过程中可能会改变相等元素的相对顺序。

#### 快速排序的代码实现

见`Quick Sort.cpp`文件。

#### 快速排序的优化（三数取中法）

在快速排序中，选择一个好的轴点（pivot）是非常重要的，因为它决定了分区的平衡性。三数取中法是一种常用的优化方法，用于选择更合适的轴点，以期望得到更平衡的分区。

***三数取中法原理***

三数取中法的基本思想是从序列的**头部**、**中部**和**尾部**各取一个数，然后将这三个数排序，取它们的中值作为轴点。

***三数取中法实现步骤***

1. **选择三个元素**：从数组中选择三个元素：第一个元素（头部）、中间的元素和最后一个元素（尾部）。
2. **排序这三个元素**：将这三个元素排序（可以使用简单的比较和交换）。
3. **选择中值作为轴点**：排序后的中间元素被选作轴点。

***三数取中法代码实现***

见`Optimized Quick Sort.cpp`文件。

## 4. 归并排序（Merge Sort）

### 4.1 二路归并（Two-Way Merge Sort）

#### 二路归并排序的原理

二路归并排序是归并排序的一种，它采用分治法（Divide and Conquer）的策略。它将数组分成两半，递归地对每部分进行排序，然后将两个有序的部分合并成一个整体的有序数组。

**算法步骤**：

1. **分解**：将当前序列分成两个子序列，长度尽量相等。
2. **递归排序**：递归地对两个子序列进行二路归并排序。
3. **合并**：将两个已排序的子序列合并成一个有序序列。

#### 二路归并排序的性能分析

- **时间复杂度**：
  - 平均情况：\(O(n\log n)\)
  - 最佳情况：\(O(n\log n)\)
  - 最坏情况：\(O(n\log n)\)

- **空间复杂度**：
  - \(O(n)\)，由于合并过程需要额外的空间来存放临时数组。

- **稳定性**：
  - 稳定。

#### 二路归并排序的代码实现

见`TwoWay Merge Sort.cpp`文件。

### 4.2 归并排序（Merge Sort）

归并排序分为**自顶向下的归并排序**与**自底向上的归并排序**，两者算法的核心思想上是一致的：均使用归并思想与二路归并算法来实现排序。故两种方法性能一样，且均与二路归并排序相同，下面是对两者的列表比较：

| 特性           | 自顶向下归并排序                        | 自底向上归并排序                        |
|--------------|----------------------------------|----------------------------------|
| 方法           | 递归实现                             | 迭代实现                             |
| 分解过程        | 从整体到单个元素，递归地分解数组               | 从单个元素开始，迭代地合并数组               |
| 合并过程        | 递归返回时合并子数组                      | 在每一轮迭代中合并固定长度的子数组           |
| 栈空间         | 需要栈空间来处理递归调用                  | 不需要使用栈空间                         |
| 适用场景        | 适合大多数环境，代码更简洁直观               | 适用于环境限制递归或堆栈空间受限的情况         |
| 优化难易度      | 递归可能更容易理解和优化                  | 需要管理多个循环和索引，可能更难以优化         |
| 适用数据结构   | 数组、链表                             | 主要是数组，链表也可以但较复杂              |

***自顶向下的归并排序(Top-Down Merge Sort)***

![Top-Down Merge Sort](images/Top-Down%20Merge%20Sort.png)

代码见`Top-Down Merge Sort.cpp`文件。

***自底向上的归并排序(Bottom-Up Merge Sort)***

![Bottom-Up Merge Sort](images/Bottom-Up%20Merge%20Sort.png)

代码见`Bottom-Up Merge Sort.cpp`文件。