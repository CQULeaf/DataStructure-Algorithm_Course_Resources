<!-- TOC -->

# 排序算法

- [排序算法](#排序算法)
  - [排序引入：了解基本概念](#排序引入了解基本概念)
    - [排序的稳定性（Sorting Stability）](#排序的稳定性sorting-stability)
    - [排序的分类](#排序的分类)
    - [排序的应用](#排序的应用)
  - [1. 插入排序（Insertion Sort）](#1-插入排序insertion-sort)
    - [1.1 直接插入排序（Straight Insertion Sort）](#11-直接插入排序straight-insertion-sort)
      - [直接插入排序的原理](#直接插入排序的原理)
      - [直接插入排序的性能分析](#直接插入排序的性能分析)
      - [直接插入排序的代码实现](#直接插入排序的代码实现)
    - [1.2 折半插入排序（Binary Insertion Sort）](#12-折半插入排序binary-insertion-sort)
      - [折半插入排序的原理](#折半插入排序的原理)
      - [折半插入排序的性能分析](#折半插入排序的性能分析)
      - [折半插入排序的代码实现](#折半插入排序的代码实现)
    - [希尔排序（Shell Sort）](#希尔排序shell-sort)
      - [希尔排序的原理](#希尔排序的原理)
      - [希尔排序的算法性能分析](#希尔排序的算法性能分析)
      - [希尔排序的代码实现](#希尔排序的代码实现)

## 排序引入：了解基本概念

### 排序的稳定性（Sorting Stability）

指对于序列中关键字值相等的节点，在排序后是否能保持原有的相对顺序。稳定性在某些应用中非常重要，因为它保证了排序过程不会打乱数据中的固有关系。

- **稳定的排序算法**：插入排序（Insertion Sort）、冒泡排序（Bubble Sort）、归并排序（Merge Sort）。
- **不稳定的排序算法**：选择排序（Selection Sort）、快速排序（Quick Sort）、堆排序（Heap Sort）。

### 排序的分类

1. **内部排序与外部排序**：
   - **内部排序**（Internal Sorting）：所有数据操作都在内存中进行。
   - **外部排序**（External Sorting）：处理的数据量很大，需要借助外部存储（如硬盘）。

2. **比较排序与分配排序**：
   - **比较排序**（Comparative Sorting）：通过比较元素间的关键字来确定顺序。例如：插入排序、冒泡排序、选择排序、快速排序、归并排序、希尔排序（Shell Sort）、堆排序。
   - **分配排序**（Distribution Sorting）：通过分配和收集来排序元素。例如：基数排序（Radix Sort）、桶排序（Bucket Sort）。

3. **难易程度**：
   - **基本排序**：如插入排序、冒泡排序、选择排序。
   - **高级排序**：如快速排序、归并排序、堆排序、基数排序。

### 排序的应用

1. **最近数据对（Closest Pair）**：在排序后的序列中，差值最小的两个数据相邻，便于快速查找。
2. **数据的唯一性（Element Uniqueness）**：通过排序后的序列来判断数据是否有重复，相邻元素比较可以轻松发现重复。
3. **统计数据出现次数（Frequency Distribution – Mode）**：排序后，相同的数据会连续出现，方便统计每种数据的出现次数。
4. **中位数与选择（Median and Selection）**：排序后，可以直接访问第k个位置的元素来得到第k小的数据。

## 1. 插入排序（Insertion Sort）

### 1.1 直接插入排序（Straight Insertion Sort）

#### 直接插入排序的原理

直接插入排序通过构建有序序列，对于未排序数据，在已排序序列中**从后向前**扫描，找到相应位置并插入。具体步骤如下：

1. **开始时**：将数组的第一个元素视为已排序的序列，其余为未排序序列。
2. **从第二个元素开始**：取出未排序序列中的第一个元素，即当前元素。
3. **比较和插入**：将当前元素与已排序序列中的元素从后向前依次比较。如果已排序元素大于当前元素，则已排序元素向后移动一位，为当前元素腾出空间。
4. **插入元素**：重复上述比较过程，直到找到一个已排序元素小于或等于当前元素的位置，将当前元素插入此位置。
5. **重复步骤 2-4**：对所有未排序的元素重复以上步骤。

![Straight Insertion Sort](images/Straight%20Insertion%20Sort.png "对关键词序列升序排序")

#### 直接插入排序的性能分析

- **时间复杂度**：
  - 平均情况：\(O(n^2)\)
  - 最坏情况：\(O(n^2)\)（当输入序列完全逆序时）

- **空间复杂度**：
  - \(O(1)\)，直接插入排序是原地排序算法。

- **稳定性**：
  - 稳定。插入排序不改变相同元素的相对顺序。

#### 直接插入排序的代码实现

见`Straight Insertion Sort.cpp`文件。

### 1.2 折半插入排序（Binary Insertion Sort）

#### 折半插入排序的原理

折半插入排序是直接插入排序的一个变体，主要改进在于查找插入位置的过程。它通过二分查找（折半查找）来减少比较次数，尽管在插入时仍需要移动元素。

**算法步骤**：

1. **初始状态**：将数组的第一个元素视为已排序序列，其余为未排序序列。
2. **对未排序的每个元素**：对于未排序序列中的每一个元素（从第二个元素开始），进行以下操作：
   - 使用二分查找在已排序序列中找到该元素的正确位置。
   - 将已排序序列中的元素向后移动，以便为新元素腾出空间。
   - 将该元素插入到找到的位置。
3. **重复**：重复步骤 2，直到所有元素都被排序。

#### 折半插入排序的性能分析

- **时间复杂度**：
  - 平均情况：\(O(n^2)\)
  - 最坏情况：\(O(n^2)\)

  尽管折半插入排序减少了比较次数，但元素的移动次数依然是\(O(n^2)\)。

- **空间复杂度**：
  - \(O(1)\)，原地排序算法。

- **稳定性**：
  - 稳定。折半插入排序不改变相同元素的相对顺序。

#### 折半插入排序的代码实现

见`Binary Insertion Sort.cpp`文件。

### 希尔排序（Shell Sort）

#### 希尔排序的原理

希尔排序，也被称为“缩小增量排序”，是直接插入排序的一种高效改进版本。它通过将原始数据分割成多个子序列，分别进行直接插入排序，逐步达到整个序列的排序。

![Shell Sort](images/Shell%20Sort.png "增量分别为8,4,2,1")

**算法步骤**：

1. **选择增量序列**：首先选择一个增量序列 \(t_1, t_2, ..., t_k\)，其中 \(t_k=1\)（通常使用序列的长度逐步减半作为增量，直至为1）。
2. **按增量序列分组**：根据当前增量 \(t_i\)，将序列分为若干组，每组包含间隔为 \(t_i\) 的元素。
3. **分组内排序**：对每个分组应用直接插入排序。
4. **减小增量重复**：取下一个增量 \(t_{i-1}\)，重复步骤 2 和 3，直到增量为 1。

#### 希尔排序的算法性能分析

- **时间复杂度**：
  - 平均情况：依赖于增量序列，一般优于 \(O(n^2)\)，但不同的增量序列有不同的性能。
  - 最坏情况：取决于增量序列，最差可达 \(O(n^2)\)。

- **空间复杂度**：
  - \(O(1)\)，希尔排序是原地排序算法。

- **稳定性**：
  - 不稳定。由于增量的存在，可能会导致相同元素的相对位置发生变化。

#### 希尔排序的代码实现

见`Shell Sort.cpp`文件。

