<!-- TOC -->

# 排序算法

## 排序引入：了解基本概念

### 排序的稳定性（Sorting Stability）

指对于序列中关键字值相等的节点，在排序后是否能保持原有的相对顺序。稳定性在某些应用中非常重要，因为它保证了排序过程不会打乱数据中的固有关系。

- **稳定的排序算法**：插入排序（Insertion Sort）、冒泡排序（Bubble Sort）、归并排序（Merge Sort）。
- **不稳定的排序算法**：选择排序（Selection Sort）、快速排序（Quick Sort）、堆排序（Heap Sort）。

### 排序的分类

1. **内部排序与外部排序**：
   - **内部排序**（Internal Sorting）：所有数据操作都在内存中进行。
   - **外部排序**（External Sorting）：处理的数据量很大，需要借助外部存储（如硬盘）。

2. **比较排序与分配排序**：
   - **比较排序**（Comparative Sorting）：通过比较元素间的关键字来确定顺序。例如：插入排序、冒泡排序、选择排序、快速排序、归并排序、希尔排序（Shell Sort）、堆排序。
   - **分配排序**（Distribution Sorting）：通过分配和收集来排序元素。例如：基数排序（Radix Sort）、桶排序（Bucket Sort）。

3. **难易程度**：
   - **基本排序**：如插入排序、冒泡排序、选择排序。
   - **高级排序**：如快速排序、归并排序、堆排序、基数排序。

### 排序的应用

1. **最近数据对（Closest Pair）**：在排序后的序列中，差值最小的两个数据相邻，便于快速查找。
2. **数据的唯一性（Element Uniqueness）**：通过排序后的序列来判断数据是否有重复，相邻元素比较可以轻松发现重复。
3. **统计数据出现次数（Frequency Distribution – Mode）**：排序后，相同的数据会连续出现，方便统计每种数据的出现次数。
4. **中位数与选择（Median and Selection）**：排序后，可以直接访问第k个位置的元素来得到第k小的数据。

## 1. 插入排序（Insertion Sort）

### 1.1 直接插入排序（Straight Insertion Sort）

#### 直接插入排序的原理

直接插入排序通过构建有序序列，对于未排序数据，在已排序序列中**从后向前**扫描，找到相应位置并插入。具体步骤如下：

1. **开始时**：将数组的第一个元素视为已排序的序列，其余为未排序序列。
2. **从第二个元素开始**：取出未排序序列中的第一个元素，即当前元素。
3. **比较和插入**：将当前元素与已排序序列中的元素从后向前依次比较。如果已排序元素大于当前元素，则已排序元素向后移动一位，为当前元素腾出空间。
4. **插入元素**：重复上述比较过程，直到找到一个已排序元素小于或等于当前元素的位置，将当前元素插入此位置。
5. **重复步骤 2-4**：对所有未排序的元素重复以上步骤。

![Straight Insertion Sort](images/Straight%20Insertion%20Sort.png "对关键词序列升序排序")

#### 直接插入排序的性能分析

- **时间复杂度**：
  - 平均情况：\(O(n^2)\)
  - 最坏情况：\(O(n^2)\)（当输入序列完全逆序时）

- **空间复杂度**：
  - \(O(1)\)，直接插入排序是原地排序算法。

- **稳定性**：
  - 稳定。插入排序不改变相同元素的相对顺序。

#### 直接插入排序的代码实现

见`Straight Insertion Sort.cpp`文件。

### 1.2 折半插入排序（Binary Insertion Sort）

#### 折半插入排序的原理

折半插入排序是直接插入排序的一个变体，主要改进在于查找插入位置的过程。它通过二分查找（折半查找）来减少比较次数，尽管在插入时仍需要移动元素。

**算法步骤**：

1. **初始状态**：将数组的第一个元素视为已排序序列，其余为未排序序列。
2. **对未排序的每个元素**：对于未排序序列中的每一个元素（从第二个元素开始），进行以下操作：
   - 使用二分查找在已排序序列中找到该元素的正确位置。
   - 将已排序序列中的元素向后移动，以便为新元素腾出空间。
   - 将该元素插入到找到的位置。
3. **重复**：重复步骤 2，直到所有元素都被排序。

### 折半插入排序的性能分析

- **时间复杂度**：
  - 平均情况：\(O(n^2)\)
  - 最坏情况：\(O(n^2)\)

  尽管折半插入排序减少了比较次数，但元素的移动次数依然是\(O(n^2)\)。

- **空间复杂度**：
  - \(O(1)\)，原地排序算法。

- **稳定性**：
  - 稳定。折半插入排序不改变相同元素的相对顺序。

#### 折半插入排序的代码实现

