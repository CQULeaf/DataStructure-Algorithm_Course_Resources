# 树

<!-- toc -->
- [树](#树)
  - [树的基本概念](#树的基本概念)
    - [树的定义](#树的定义)
    - [树的基本术语](#树的基本术语)
    - [树的基本操作](#树的基本操作)
  - [二叉树（Binary Tree）](#二叉树binary-tree)
    - [二叉树的定义](#二叉树的定义)
    - [二叉树的基本操作](#二叉树的基本操作)
    - [特殊的二叉树](#特殊的二叉树)
    - [二叉树基本性质](#二叉树基本性质)
    - [二叉树的顺序存储方式](#二叉树的顺序存储方式)
    - [二叉树的链式存储方式](#二叉树的链式存储方式)
    - [二叉树的遍历说明](#二叉树的遍历说明)
    - [二叉树的遍历代码实现（使用双向链表）](#二叉树的遍历代码实现使用双向链表)
    - [二叉树遍历的非递归算法](#二叉树遍历的非递归算法)
  - [二叉树的应用I：表达式树（Expression Tree）](#二叉树的应用i表达式树expression-tree)
    - [表达式树的基本概念](#表达式树的基本概念)
    - [关于表达式树的相关知识](#关于表达式树的相关知识)
  - [二叉树的应用II：奇偶树（Odd-Even Tree）](#二叉树的应用ii奇偶树odd-even-tree)
    - [奇偶树的基本概念](#奇偶树的基本概念)
    - [层序遍历实现奇偶树](#层序遍历实现奇偶树)
    - [前序遍历实现奇偶树](#前序遍历实现奇偶树)

## 树的基本概念

### 树的定义

1. **树的结构**：树是一个由**结点**（Nodes）组成的有限集合。这个集合要么是空的（即没有任何结点），要么是由**一个根结点**（Root Node）和**若干个互不相交的子树**（Subtrees）组成的。这些子树本身也都是树。

2. **递归定义**：树可以递归地定义为一个根结点和一些子树，每个子树也是一个树。除了根结点外，树中的每个结点有一个父结点（Parent Node）。一个树如果有 \(n\) 个结点，那么它就有 \(n-1\) 条边（Edges），因为每个结点（除了根结点）都通过一条边与其父结点相连。

### 树的基本术语

1. **结点的度（Degree of a Node）**：子结点（Child Nodes）数量。例如，没有子结点的结点度为0。

2. **树的度（Degree of a Tree）**：树中所有结点的度的最大值。

3. **叶结点（Leaf Node）**：度为0的结点，即没有子结点的结点。

4. **中间结点（Internal Node）**：度不为0的结点，即有子结点的结点。

5. **兄弟结点（Sibling Nodes）**：具有相同父结点的结点。

6. **结点的层次（Level of a Node）**：根结点在第1层，其子结点在第2层，以此类推。

7. **结点的高度（Height of a Node）**：叶结点的高度是1，中间结点的高度是它所有子结点的高度的最大值加1。（在树结构中，每个结点的高度是基于它的子结点来确定的。）

8. **树的高度（Height of a Tree）**：根结点的高度。

9. **有序树与无序树**：如果树中结点的子树有固定的顺序，且不能交换次序，则称为有序树；否则为无序树。

10. **森林（Forest）**：零个或多个互不相交的树的集合。

11. **祖先结点和子孙结点**：如果从一个结点向根结点方向遍历，遇到的所有结点都是这个结点的祖先结点。相反，一个结点的所有下属结点都是它的子孙结点。

- ***非根结点有且仅有一个父结点***：这是因为每个结点（除了根结点）在树中都是通过一条唯一的边与其父结点相连，而这种结构确保了从任何一个非根结点到根结点的路径是唯一的。

### 树的基本操作

- **InitTree(tree)**: 初始化一个空树 `tree`。
- **CreateTree(tree, definition)**: 按照 `definition` 构造一个树。
- **IsEmpty(tree)**: 检查树 `tree` 是否为空。若为空，返回 `true`；否则，返回 `false`。
- **Root(tree)**: 返回树 `tree` 的根节点。
- **Get(tree, node)**: 返回树 `tree` 中节点 `node` 的值。
- **Parent(tree, node)**: 返回树 `tree` 中节点 `node` 的父节点。
- **GetChild(tree, node, k)**: 返回树 `tree` 中节点 `node` 的第 `k` 个子树。
- **InsertChild(tree, node, k, subtree)**: 将树 `subtree` 插入到树 `tree` 中，使其成为节点 `node` 的第 `k` 个子树。
- **Search(tree, x)**: 在树 `tree` 中查找值为 `x` 的节点。如果查找成功，返回节点；否则返回 `NIL`。
- **Traverse(tree)**: 遍历树 `tree` 中的每个节点，且每个节点只访问一次。

## 二叉树（Binary Tree）

### 二叉树的定义

1. **二叉树的基本结构**：二叉树是由节点组成的有限集合 \( T \)，用 \( |T| \) 表示节点的数量。二叉树的特点是每个节点有且仅有两个子树，并且这两个子树有左右之分，这使得二叉树成为一种**有序树**。

2. **空二叉树**：如果 \( |T| = 0 \)，则 \( T \) 是一个空树。空二叉树是没有任何节点的二叉树。

3. **非空二叉树的结构**：如果 \( |T| > 0 \)，二叉树 \( T \) 中有一个特殊的节点 \( r \)，这个节点被称为二叉树的根节点。除了根节点之外的其他节点 \( T - \{r\} \) 被划分为两个互不相交的子集 \( TL \) 和 \( TR \)：
   - **左子树** \( TL \)：是根节点 \( r \) 的左子树，本身也是一棵二叉树。如果 \( TL > 0 \)，则 \( TL \) 的根 \( r_L \) 是 \( r \) 的左子节点，同时 \( r \) 是 \( r_L \) 的父节点。
   - **右子树** \( TR \)：是根节点 \( r \) 的右子树，同样也是一棵二叉树。如果 \( TR > 0 \)，则 \( TR \) 的根 \( r_R \) 是 \( r \) 的右子节点，而 \( r \) 是 \( r_R \) 的父节点。

### 二叉树的基本操作

- **BinaryTreeNode()**: 创建一个二叉树结点。
- **CreateBinaryTree(value, left_tree, right_tree)**: 构造二叉树，根节点的数据为 `value`，左子树和右子树分别是 `left_tree` 和 `right_tree`。
- **IsLeaf(tree, node)**: 如果二叉树 `tree` 中节点 `node` 为叶节点，返回 `true`；否则返回 `false`。
- **Height(tree)**: 返回二叉树 `tree` 的高度（深度）。
- **PreOrder(tree)**: 前序遍历二叉树 `tree`。
- **InOrder(tree)**: 中序遍历二叉树 `tree`。
- **PostOrder(tree)**: 后序遍历二叉树 `tree`。
- **LevelOrder(tree)**: 层序遍历二叉树 `tree`。

### 特殊的二叉树

当然，以下是一个表格形式的总结，列出满二叉树、完全二叉树和完美二叉树的定义、特点和实例：

| 特殊的二叉树类型             | 定义                                                                                     | 特点                                                                                                  | 实例                  |
|----------------|----------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------|---------------------|
| 满二叉树（Full Binary Tree） | 由度为0的叶结点和度为2的中间结点构成的二叉树，树中没有度为1的结点。                                              |  所有的非叶节点都具有两个子节点。                                               | 哈夫曼树（Huffman Tree） 表达式树（Expression Tree） |
| 完全二叉树（Complete Binary Tree） | 除了最后一层，所有的层都是满的。在最后一层，所有的节点都尽可能地靠左排列。                                     |  可以有一些叶节点缺失。 最后一层的叶节点向左对齐。 适合用数组来表示。                            |  二叉堆（Binary Heap）       |
| 完美二叉树（Perfect Binary Tree） | 所有非叶节点都有两个子节点，并且所有叶节点都在同一层级上，此外每一层的节点数是最大可能节点数的情况下的节点数。 |  所有层都是完全填满的。 叶节点数量是非叶节点数量加一。节点总数是 \(2^{k} - 1\)（其中 \(k\) 是树的高度）。 |  满二叉搜索树          |

***左为满二叉树，右为非满二叉树***
![Full Binary Tree](images/Full%20Binary%20Tree.png)

***完全二叉树***
![Complete Binary Tree](images/Complete%20Binary%20Tree.png)

***完美二叉树***
![Perfect Binary Tree](images/Perfect%20Binary%20Tree.png)

### 二叉树基本性质

1. **二叉树的层级结构**
   - **命题：** 在二叉树的第 \(i\) 层，最多有 \(2^{i-1}\) 个结点（\(i \geq 1\)）。
   - 这展示了二叉树每层的最大节点数，随层级增加呈指数增长。

2. **二叉树的最大节点数**
   - **命题：** 深度（高度）为 \(d\)（\(d \geq 1\)）的二叉树最多有 \(2^d - 1\) 个结点。
   - 这描述了二叉树在给定深度下的最大节点数，是对树的整体大小的一个重要指标。

3. **完美二叉树的特征**
   - **定理：** 深度（高度）为 \(d\)（\(d \geq 1\)）的二叉树是完美二叉树的充分必要条件是该树中有 \(2^d - 1\) 个结点。
   - 完美二叉树是每一层都完全填满的二叉树，这个定理说明了其结构上的严格性。

4. **完全二叉树的节点关系**
   - **定理：** 完全二叉树有 \(n\) 个结点（\(n \geq 1\)），按层次从左向右编号。对于任意结点 \(k\)（\(1 \leq k \leq n\)）：
     - 如果 \(2k \leq n\)，则结点 \(k\) 的左子结点是 \(2k\)；否则没有左子结点。
     - 如果 \(2k + 1 \leq n\)，则结点 \(k\) 的右子结点是 \(2k + 1\)；否则没有右子结点。
     - 如果 \(k > 1\)，则结点 \(k\) 的父结点是 \([k/2]\)。
   - 这是完全二叉树实现顺序存储以及二叉堆的重要性质。

5. **完全二叉树的深度计算**
   - **命题：** 有 \(n\) 个结点（\(n \geq 1\)）的完全二叉树的深度 \(d\) 为 \( \text{log}_2(n + 1) \)。
   - 提供了计算给定节点数的完全二叉树深度的方法。

6. **满二叉树与节点关系**
   - **命题：** 设非空二叉树中度为 \(i \in [0, 2]\) 的结点数为 \(n_i\)，则 \(n_0 = n_2 + 1\)。
   - 对于满二叉树，叶结点（度为0的结点）的数量比度为2的结点的数量多1。

### 二叉树的顺序存储方式

**方式**：

- **完全二叉树**：可以分层从左向右连续编号，使用一组地址连续的存储单元（顺序表）存储二叉树的各个节点。

![The Sequential Storage of Complete Binary Tree 1](images/The%20Squential%20Storage%20of%20Complete%20Binary%20Tree%201.png)

![The Sequential Storage of Complete Binary Tree 2](images/The%20Squential%20Storage%20of%20Complete%20Binary%20Tree%202.png)

- **非完全二叉树**：
  - 结点编号：树根的索引为1；设结点的编号为 \( k \)（\( k \geq 1 \)），如果左子树非空，则左子节点的编号为 \( 2k \)；如果右子树非空，则右子节点的编号为 \( 2k + 1 \)。
  - 顺序存放：用一组地址连续的存储单元存储二叉树的各个节点。

![The Sequential Non-Storage of Complete Binary Tree 1](images/The%20Squential%20Storage%20of%20Non-Complete%20Binary%20Tree%201.png)

![The Sequential Non-Storage of Complete Binary Tree 2](images/The%20Squential%20Storage%20of%20Non-Complete%20Binary%20Tree%202.png)

**优缺点分析**:

| 优点 | 缺点 |
|------|------|
| 1. **简化存储结构**：使用顺序表存储节点，省去了维护节点间关系的额外存储需求。 | 1. **空间效率问题**：对于非完全二叉树，顺序存储可能会导致存储空间的浪费。 |
| 2. **直观的节点关系**：节点的父子关系可以直接通过它们在顺序表中的位置来确定，无需额外计算。 | 2. **潜在的空间不足**：在极端情况下，二叉树可能需要的存储空间远大于实际节点数，尤其是当树的深度很大时。 |
| 3. **高效的节点访问**：查找一个节点的子节点或父节点只需要简单的数学运算，效率很高。 | 3. **逻辑关系的复杂性**：虽然降低了空间复杂度，但确定节点间的父子关系时，可能需要更复杂的操作，影响效率。 |
| 4. **适合完全二叉树**：对于完全二叉树，顺序存储是一种非常高效且节省空间的方式。 |      |

### 二叉树的链式存储方式

**方式**：

| 类型 | 数据域 | 左子指针 | 右子指针 | 父指针 | 特点 |
|------|--------|----------|----------|--------|------|
| 二叉链表 | 存储数据 | 指向左子节点 | 指向右子节点 | 无 | 直接通过指针访问子节点 |
| 三叉链表 | 存储数据 | 指向左子节点 | 指向右子节点 | 指向父节点 | 访问父节点和子节点都很方便 |

![Binary Linked List](images/Binary%20Linked%20List.png)
![Three-Pronged Linked List](images/Three-Pronged%20Linked%20List.png)

**优缺点分析**：

| 优点 | 缺点 |
|------|------|
| **动态结构**：允许树动态地增长或缩小，适用于树结构频繁变化的场景。 | **额外空间消耗**：每个节点需要额外空间来存储指针，可能占用更多内存。 |
| **无需预估空间**：不需要像顺序存储那样预先分配固定大小的存储空间，按需分配。 | **访问时间长**：查找特定节点可能需要更多时间，因为需要遍历指针。 |
| **高效的节点操作**：插入和删除节点操作相对高效，无需移动其他节点。 | **无随机访问**：不能直接通过索引访问，访问节点通常需要从根节点开始顺序查找。 |
| **空间利用率高**：只为实际存在的节点分配空间，避免了空间浪费。 | **管理复杂性**：需要正确处理多个指针，否则可能导致内存泄漏或数据结构损坏。 |

### 二叉树的遍历说明

二叉树的遍历是指访问树中每个节点，且确保每个节点仅被访问一次。
二叉树的遍历主要分为两类：深度优先遍历（Depth-First Search, DFS）和广度优先遍历（Breadth-First Search, BFS）。

**深度优先遍历（Depth-First Search, DFS）**：

深度优先遍历是沿着树的深度遍历树的节点，尽可能深的搜索树的分支。

1. **前序遍历（Pre-order Traversal）**：
   - 遍历顺序：根节点 -> 左子树 -> 右子树。
   - 首先访问根节点，然后递归地对左子树进行前序遍历，最后递归地对右子树进行前序遍历。

2. **中序遍历（In-order Traversal）**：
   - 遍历顺序：左子树 -> 根节点 -> 右子树。
   - 首先递归地对左子树进行中序遍历，然后访问根节点，最后递归地对右子树进行中序遍历。

3. **后序遍历（Post-order Traversal）**：
   - 遍历顺序：左子树 -> 右子树 -> 根节点。
   - 首先递归地对左子树进行后序遍历，然后递归地对右子树进行后序遍历，最后访问根节点。

**广度优先遍历（Breadth-First Search, BFS）**：

广度优先遍历是逐层遍历树的节点，先访问离根节点近的层，再访问离根节点远的层。

1. **层序遍历（Level-order Traversal）**：
   - 遍历顺序：逐层从左至右遍历所有节点。
   - 从根节点开始，首先访问第一层（根节点），然后逐层向下，对每一层的节点从左到右进行访问。

### 二叉树的遍历代码实现（使用双向链表）

见`The Implementation of Binary Tree.cpp`文件。

### 二叉树遍历的非递归算法

相对于递归算法，非递归算法遍历二叉树有以下优势：

1. **适用性广泛**：有些编程语言不支持或不适合使用递归。
2. **内存效率更高**：递归算法会在系统的内存栈中为每一层递归调用分配空间，存储参数和局部变量。对于深度较大的树，这可能导致内存栈空间不足，甚至栈溢出。而非递归算法通过**显式**使用栈结构，有效控制内存使用。
3. **运行效率提升**：在某些情况下，非递归算法由于减少了函数调用开销，可以提供更好的运行效率。

非递归算法实现遍历的步骤：

前序遍历（Pre-order）

1. 创建一个空栈。
2. 将根节点压入栈中。
3. 当栈不为空时：
   - 弹出栈顶元素，并访问该节点。
   - 将节点的右子节点（如果有）压入栈。
   - 将节点的左子节点（如果有）压入栈。
4. 重复步骤3，直到栈为空。

中序遍历（In-order）

1. 创建一个空栈。
2. 从根节点开始，遍历节点的左子树，并将节点压入栈中，直至左子树为空。
3. 当栈不为空时：
   - 弹出栈顶元素，并访问该节点。
   - 转向该节点的右子树并重复步骤2和3。

后序遍历（Post-order）

1. 创建两个栈。
2. 将根节点压入第一个栈中。
3. 当第一个栈不为空时：
   - 弹出一个元素，压入第二个栈中。
   - 将该节点的左子节点和右子节点压入第一个栈中。
4. 依次弹出第二个栈中的元素并访问。

非递归算法实现遍历的代码实现：

见`Traverse Binary Tree with Non Recrusion.cpp`文件

## 二叉树的应用I：表达式树（Expression Tree）

### 表达式树的基本概念

- 表达式树是一种特殊的二叉树，用于表示数学算术表达式。
- 在这种树中，每个叶节点代表一个数值（如常数），而每个内部节点代表一个运算符（如`+`、`-`、`*`、`/`）。

### 关于表达式树的相关知识

1. **构建方式**：
   - 对于单个常数，表达式树是一个单节点树，节点即为该常数。
   - 对于包含多个常数和运算符的表达式，将表达式递归地分解成`(expr_left) op (expr_right)`的形式，其中`op`是运算符，`expr_left`和`expr_right`分别是左右子表达式。
   - 在树中，运算符`op`成为内部节点，而`expr_left`和`expr_right`分别构成该节点的左右子树。

2. **遍历与表达式表示**：
   - **前序遍历（根-左-右）**：生成前缀表示法的表达式。
   - **中序遍历（左-根-右）**：生成中缀表示法的表达式，但需要适当加括号以保持运算优先级，否则可能不代表正确的表达式。
   - **后序遍历（左-右-根）**：生成后缀表示法的表达式。

3. **括号的重要性**：
   - 在使用中序遍历表达中缀形式时，必须正确使用括号以保证表达式的意义明确。这是因为不同运算符具有不同的优先级。

4. **应用场景**：
   - 表达式树在编译器设计、算术表达式处理、符号计算等领域中非常重要，它帮助我们理解和操作复杂的算术表达式。

5. **代码实现**:
   - 打印带有冗余括号的中缀表达式。见`Print Infix Expression.cpp`文件。

## 二叉树的应用II：奇偶树（Odd-Even Tree）

### 奇偶树的基本概念

奇偶树（Odd-Even Tree）是一种特殊的二叉树。在这种树中，所有位于奇数层（第 1 层、第 3 层等）的节点存储的元素必须是奇数，而所有位于偶数层（第 2 层、第 4 层等）的节点存储的元素必须是偶数。

### 层序遍历实现奇偶树

**具体实现步骤：**

1. 使用两个队列，一个用于存储节点，另一个用于存储节点所在的层级。
2. 将根节点和层数 1 加入对应的队列。
3. 循环执行以下步骤，直到节点队列为空：
   - 从队列中弹出一个节点和它的层数。
   - 检查节点值和层数的奇偶性是否一致。如果不一致，返回 `false`。
   - 如果有左子节点或右子节点，将它们及其层数（当前节点层数+1）加入队列。

### 前序遍历实现奇偶树

