# 树

<!-- toc -->
- [树](#树)
  - [树的基本概念](#树的基本概念)
    - [树的定义](#树的定义)
    - [树的基本术语](#树的基本术语)
    - [树的基本操作](#树的基本操作)
  - [二叉树（Binary Tree）](#二叉树binary-tree)
    - [二叉树的定义](#二叉树的定义)
    - [二叉树的基本操作](#二叉树的基本操作)
    - [特殊的二叉树](#特殊的二叉树)
    - [二叉树基本性质](#二叉树基本性质)
    - [二叉树的存储方式](#二叉树的存储方式)
      - [二叉树的顺序存储方式](#二叉树的顺序存储方式)
      - [二叉树的链式存储方式](#二叉树的链式存储方式)
    - [二叉树的遍历](#二叉树的遍历)
      - [二叉树的遍历说明](#二叉树的遍历说明)
      - [二叉树的遍历代码实现（使用双向链表）](#二叉树的遍历代码实现使用双向链表)
      - [二叉树遍历的非递归算法](#二叉树遍历的非递归算法)
    - [二叉树的应用I：表达式树（Expression Tree）](#二叉树的应用i表达式树expression-tree)
      - [表达式树的基本概念](#表达式树的基本概念)
      - [关于表达式树的相关知识](#关于表达式树的相关知识)
    - [二叉树的应用II：奇偶树（Odd-Even Tree）](#二叉树的应用ii奇偶树odd-even-tree)
      - [奇偶树的基本概念](#奇偶树的基本概念)
      - [层序遍历判断奇偶树](#层序遍历判断奇偶树)
      - [前序遍历判断奇偶树](#前序遍历判断奇偶树)
      - [一种特殊的奇偶树](#一种特殊的奇偶树)
      - [层序遍历方法判断该特殊奇偶树](#层序遍历方法判断该特殊奇偶树)
    - [二叉树的应用III：二叉树的序列化（Serialization）与反序列化（Deserialization）](#二叉树的应用iii二叉树的序列化serialization与反序列化deserialization)
      - [二叉树的序列化与反序列化是什么？](#二叉树的序列化与反序列化是什么)
      - [序列化与反序列化的问题？](#序列化与反序列化的问题)
      - [如何进行序列化与反序列化？](#如何进行序列化与反序列化)
      - [前序遍历下序列化与反序列化代码实现](#前序遍历下序列化与反序列化代码实现)
      - [前序+中序遍历重构二叉树](#前序中序遍历重构二叉树)
  - [哈夫曼树（Huffman Tree）](#哈夫曼树huffman-tree)
    - [哈夫曼树基本概念](#哈夫曼树基本概念)
    - [哈夫曼树的基本性质](#哈夫曼树的基本性质)
    - [哈夫曼算法](#哈夫曼算法)
      - [哈夫曼算法步骤](#哈夫曼算法步骤)
      - [哈夫曼算法核心要点](#哈夫曼算法核心要点)
      - [哈夫曼算法代码实现](#哈夫曼算法代码实现)
    - [哈夫曼树的应用I：哈夫曼编码](#哈夫曼树的应用i哈夫曼编码)
      - [编码的基本概念](#编码的基本概念)
      - [哈夫曼编码](#哈夫曼编码)
      - [构建前缀码树](#构建前缀码树)
      - [编码效率](#编码效率)
      - [解码哈夫曼编码](#解码哈夫曼编码)
    - [哈夫曼树的应用II：多路合并](#哈夫曼树的应用ii多路合并)
      - [多路合并问题描述](#多路合并问题描述)
      - [两种合并方案：同步归并和按序合并](#两种合并方案同步归并和按序合并)
      - [哈夫曼树在多路合并中的应用](#哈夫曼树在多路合并中的应用)
      - [两种合并方案效率对比](#两种合并方案效率对比)

## 树的基本概念

### 树的定义

1. **树的结构**：树是一个由**结点**（Nodes）组成的有限集合。这个集合要么是空的（即没有任何结点），要么是由**一个根结点**（Root Node）和**若干个互不相交的子树**（Subtrees）组成的。这些子树本身也都是树。

2. **递归定义**：树可以递归地定义为一个根结点和一些子树，每个子树也是一个树。除了根结点外，树中的每个结点有一个父结点（Parent Node）。一个树如果有 \(n\) 个结点，那么它就有 \(n-1\) 条边（Edges），因为每个结点（除了根结点）都通过一条边与其父结点相连。

### 树的基本术语

1. **结点的度（Degree of a Node）**：子结点（Child Nodes）数量。例如，没有子结点的结点度为0。

2. **树的度（Degree of a Tree）**：树中所有结点的度的最大值。

3. **叶结点（Leaf Node）**：度为0的结点，即没有子结点的结点。

4. **中间结点（Internal Node）**：度不为0的结点，即有子结点的结点。

5. **兄弟结点（Sibling Nodes）**：具有相同父结点的结点。

6. **结点的层次（Level of a Node）**：根结点在第1层，其子结点在第2层，以此类推。

7. **结点的高度（Height of a Node）**：叶结点的高度是1，中间结点的高度是它所有子结点的高度的最大值加1。（在树结构中，每个结点的高度是基于它的子结点来确定的。）

8. **树的高度（Height of a Tree）**：根结点的高度。

9. **有序树与无序树**：如果树中结点的子树有固定的顺序，且不能交换次序，则称为有序树；否则为无序树。

10. **森林（Forest）**：零个或多个互不相交的树的集合。

11. **祖先结点和子孙结点**：如果从一个结点向根结点方向遍历，遇到的所有结点都是这个结点的祖先结点。相反，一个结点的所有下属结点都是它的子孙结点。

- ***非根结点有且仅有一个父结点***：这是因为每个结点（除了根结点）在树中都是通过一条唯一的边与其父结点相连，而这种结构确保了从任何一个非根结点到根结点的路径是唯一的。

### 树的基本操作

- **InitTree(tree)**: 初始化一个空树 `tree`。
- **CreateTree(tree, definition)**: 按照 `definition` 构造一个树。
- **IsEmpty(tree)**: 检查树 `tree` 是否为空。若为空，返回 `true`；否则，返回 `false`。
- **Root(tree)**: 返回树 `tree` 的根节点。
- **Get(tree, node)**: 返回树 `tree` 中节点 `node` 的值。
- **Parent(tree, node)**: 返回树 `tree` 中节点 `node` 的父节点。
- **GetChild(tree, node, k)**: 返回树 `tree` 中节点 `node` 的第 `k` 个子树。
- **InsertChild(tree, node, k, subtree)**: 将树 `subtree` 插入到树 `tree` 中，使其成为节点 `node` 的第 `k` 个子树。
- **Search(tree, x)**: 在树 `tree` 中查找值为 `x` 的节点。如果查找成功，返回节点；否则返回 `NIL`。
- **Traverse(tree)**: 遍历树 `tree` 中的每个节点，且每个节点只访问一次。

## 二叉树（Binary Tree）

### 二叉树的定义

1. **二叉树的基本结构**：二叉树是由节点组成的有限集合 \( T \)，用 \( |T| \) 表示节点的数量。二叉树的特点是每个节点有且仅有两个子树，并且这两个子树有左右之分，这使得二叉树成为一种**有序树**。

2. **空二叉树**：如果 \( |T| = 0 \)，则 \( T \) 是一个空树。空二叉树是没有任何节点的二叉树。

3. **非空二叉树的结构**：如果 \( |T| > 0 \)，二叉树 \( T \) 中有一个特殊的节点 \( r \)，这个节点被称为二叉树的根节点。除了根节点之外的其他节点 \( T - \{r\} \) 被划分为两个互不相交的子集 \( TL \) 和 \( TR \)：
   - **左子树** \( TL \)：是根节点 \( r \) 的左子树，本身也是一棵二叉树。如果 \( TL > 0 \)，则 \( TL \) 的根 \( r_L \) 是 \( r \) 的左子节点，同时 \( r \) 是 \( r_L \) 的父节点。
   - **右子树** \( TR \)：是根节点 \( r \) 的右子树，同样也是一棵二叉树。如果 \( TR > 0 \)，则 \( TR \) 的根 \( r_R \) 是 \( r \) 的右子节点，而 \( r \) 是 \( r_R \) 的父节点。

### 二叉树的基本操作

- **BinaryTreeNode()**: 创建一个二叉树结点。
- **CreateBinaryTree(value, left_tree, right_tree)**: 构造二叉树，根节点的数据为 `value`，左子树和右子树分别是 `left_tree` 和 `right_tree`。
- **IsLeaf(tree, node)**: 如果二叉树 `tree` 中节点 `node` 为叶节点，返回 `true`；否则返回 `false`。
- **Height(tree)**: 返回二叉树 `tree` 的高度（深度）。
- **PreOrder(tree)**: 前序遍历二叉树 `tree`。
- **InOrder(tree)**: 中序遍历二叉树 `tree`。
- **PostOrder(tree)**: 后序遍历二叉树 `tree`。
- **LevelOrder(tree)**: 层序遍历二叉树 `tree`。

### 特殊的二叉树

当然，以下是一个表格形式的总结，列出满二叉树、完全二叉树和完美二叉树的定义、特点和实例：

| 特殊的二叉树类型             | 定义                                                                                     | 特点                                                                                                  | 实例                  |
|----------------|----------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------|---------------------|
| 满二叉树（Full Binary Tree） | 由度为0的叶结点和度为2的中间结点构成的二叉树，树中没有度为1的结点。                                              |  所有的非叶节点都具有两个子节点。                                               | 哈夫曼树（Huffman Tree） 表达式树（Expression Tree） |
| 完全二叉树（Complete Binary Tree） | 除了最后一层，所有的层都是满的。在最后一层，所有的节点都尽可能地靠左排列。                                     |  可以有一些叶节点缺失。 最后一层的叶节点向左对齐。 适合用数组来表示。                            |  二叉堆（Binary Heap）       |
| 完美二叉树（Perfect Binary Tree） | 所有非叶节点都有两个子节点，并且所有叶节点都在同一层级上，此外每一层的节点数是最大可能节点数的情况下的节点数。 |  所有层都是完全填满的。 叶节点数量是非叶节点数量加一。节点总数是 \(2^{k} - 1\)（其中 \(k\) 是树的高度）。 |  满二叉搜索树          |

***左为满二叉树，右为非满二叉树***
![Full Binary Tree](images/Full%20Binary%20Tree.png)

***完全二叉树***
![Complete Binary Tree](images/Complete%20Binary%20Tree.png)

***完美二叉树***
![Perfect Binary Tree](images/Perfect%20Binary%20Tree.png)

### 二叉树基本性质

1. **二叉树的层级结构**
   - **命题：** 在二叉树的第 \(i\) 层，最多有 \(2^{i-1}\) 个结点（\(i \geq 1\)）。
   - 这展示了二叉树每层的最大节点数，随层级增加呈指数增长。

2. **二叉树的最大节点数**
   - **命题：** 深度（高度）为 \(d\)（\(d \geq 1\)）的二叉树最多有 \(2^d - 1\) 个结点。
   - 这描述了二叉树在给定深度下的最大节点数，是对树的整体大小的一个重要指标。

3. **完美二叉树的特征**
   - **定理：** 深度（高度）为 \(d\)（\(d \geq 1\)）的二叉树是完美二叉树的充分必要条件是该树中有 \(2^d - 1\) 个结点。
   - 完美二叉树是每一层都完全填满的二叉树，这个定理说明了其结构上的严格性。

4. **完全二叉树的节点关系**
   - **定理：** 完全二叉树有 \(n\) 个结点（\(n \geq 1\)），按层次从左向右编号。对于任意结点 \(k\)（\(1 \leq k \leq n\)）：
     - 如果 \(2k \leq n\)，则结点 \(k\) 的左子结点是 \(2k\)；否则没有左子结点。
     - 如果 \(2k + 1 \leq n\)，则结点 \(k\) 的右子结点是 \(2k + 1\)；否则没有右子结点。
     - 如果 \(k > 1\)，则结点 \(k\) 的父结点是 \([k/2]\)。
   - 这是完全二叉树实现顺序存储以及二叉堆的重要性质。

5. **完全二叉树的深度计算**
   - **命题：** 有 \(n\) 个结点（\(n \geq 1\)）的完全二叉树的深度 \(d\) 为 \( \text{log}_2(n + 1) \)。
   - 提供了计算给定节点数的完全二叉树深度的方法。

6. **满二叉树与节点关系**
   - **命题：** 设非空二叉树中度为 \(i \in [0, 2]\) 的结点数为 \(n_i\)，则 \(n_0 = n_2 + 1\)。
   - 对于满二叉树，叶结点（度为0的结点）的数量比度为2的结点的数量多1。

### 二叉树的存储方式

#### 二叉树的顺序存储方式

**方式**：

- **完全二叉树**：可以分层从左向右连续编号，使用一组地址连续的存储单元（顺序表）存储二叉树的各个节点。

![The Sequential Storage of Complete Binary Tree 1](images/The%20Squential%20Storage%20of%20Complete%20Binary%20Tree%201.png)

![The Sequential Storage of Complete Binary Tree 2](images/The%20Squential%20Storage%20of%20Complete%20Binary%20Tree%202.png)

- **非完全二叉树**：
  - 结点编号：树根的索引为1；设结点的编号为 \( k \)（\( k \geq 1 \)），如果左子树非空，则左子节点的编号为 \( 2k \)；如果右子树非空，则右子节点的编号为 \( 2k + 1 \)。
  - 顺序存放：用一组地址连续的存储单元存储二叉树的各个节点。

![The Sequential Non-Storage of Complete Binary Tree 1](images/The%20Squential%20Storage%20of%20Non-Complete%20Binary%20Tree%201.png)

![The Sequential Non-Storage of Complete Binary Tree 2](images/The%20Squential%20Storage%20of%20Non-Complete%20Binary%20Tree%202.png)

**优缺点分析**:

| 优点 | 缺点 |
|------|------|
| 1. **简化存储结构**：使用顺序表存储节点，省去了维护节点间关系的额外存储需求。 | 1. **空间效率问题**：对于非完全二叉树，顺序存储可能会导致存储空间的浪费。 |
| 2. **直观的节点关系**：节点的父子关系可以直接通过它们在顺序表中的位置来确定，无需额外计算。 | 2. **潜在的空间不足**：在极端情况下，二叉树可能需要的存储空间远大于实际节点数，尤其是当树的深度很大时。 |
| 3. **高效的节点访问**：查找一个节点的子节点或父节点只需要简单的数学运算，效率很高。 | 3. **逻辑关系的复杂性**：虽然降低了空间复杂度，但确定节点间的父子关系时，可能需要更复杂的操作，影响效率。 |
| 4. **适合完全二叉树**：对于完全二叉树，顺序存储是一种非常高效且节省空间的方式。 |      |

#### 二叉树的链式存储方式

**方式**：

| 类型 | 数据域 | 左子指针 | 右子指针 | 父指针 | 特点 |
|------|--------|----------|----------|--------|------|
| 二叉链表 | 存储数据 | 指向左子节点 | 指向右子节点 | 无 | 直接通过指针访问子节点 |
| 三叉链表 | 存储数据 | 指向左子节点 | 指向右子节点 | 指向父节点 | 访问父节点和子节点都很方便 |

![Binary Linked List](images/Binary%20Linked%20List.png)
![Three-Pronged Linked List](images/Three-Pronged%20Linked%20List.png)

**优缺点分析**：

| 优点 | 缺点 |
|------|------|
| **动态结构**：允许树动态地增长或缩小，适用于树结构频繁变化的场景。 | **额外空间消耗**：每个节点需要额外空间来存储指针，可能占用更多内存。 |
| **无需预估空间**：不需要像顺序存储那样预先分配固定大小的存储空间，按需分配。 | **访问时间长**：查找特定节点可能需要更多时间，因为需要遍历指针。 |
| **高效的节点操作**：插入和删除节点操作相对高效，无需移动其他节点。 | **无随机访问**：不能直接通过索引访问，访问节点通常需要从根节点开始顺序查找。 |
| **空间利用率高**：只为实际存在的节点分配空间，避免了空间浪费。 | **管理复杂性**：需要正确处理多个指针，否则可能导致内存泄漏或数据结构损坏。 |

### 二叉树的遍历

#### 二叉树的遍历说明

二叉树的遍历是指访问树中每个节点，且确保每个节点仅被访问一次。
二叉树的遍历主要分为两类：深度优先遍历（Depth-First Search, DFS）和广度优先遍历（Breadth-First Search, BFS）。

**深度优先遍历（Depth-First Search, DFS）**：

深度优先遍历是沿着树的深度遍历树的节点，尽可能深的搜索树的分支。

1. **前序遍历（Pre-order Traversal）**：
   - 遍历顺序：根节点 -> 左子树 -> 右子树。
   - 首先访问根节点，然后递归地对左子树进行前序遍历，最后递归地对右子树进行前序遍历。

2. **中序遍历（In-order Traversal）**：
   - 遍历顺序：左子树 -> 根节点 -> 右子树。
   - 首先递归地对左子树进行中序遍历，然后访问根节点，最后递归地对右子树进行中序遍历。

3. **后序遍历（Post-order Traversal）**：
   - 遍历顺序：左子树 -> 右子树 -> 根节点。
   - 首先递归地对左子树进行后序遍历，然后递归地对右子树进行后序遍历，最后访问根节点。

**广度优先遍历（Breadth-First Search, BFS）**：

广度优先遍历是逐层遍历树的节点，先访问离根节点近的层，再访问离根节点远的层。

1. **层序遍历（Level-order Traversal）**：
   - 遍历顺序：逐层从左至右遍历所有节点。
   - 从根节点开始，首先访问第一层（根节点），然后逐层向下，对每一层的节点从左到右进行访问。

#### 二叉树的遍历代码实现（使用双向链表）

见`The Implementation of Binary Tree.cpp`文件。

#### 二叉树遍历的非递归算法

相对于递归算法，非递归算法遍历二叉树有以下优势：

1. **适用性广泛**：有些编程语言不支持或不适合使用递归。
2. **内存效率更高**：递归算法会在系统的内存栈中为每一层递归调用分配空间，存储参数和局部变量。对于深度较大的树，这可能导致内存栈空间不足，甚至栈溢出。而非递归算法通过**显式**使用栈结构，有效控制内存使用。
3. **运行效率提升**：在某些情况下，非递归算法由于减少了函数调用开销，可以提供更好的运行效率。

非递归算法实现遍历的步骤：

前序遍历（Pre-order）

1. 创建一个空栈。
2. 将根节点压入栈中。
3. 当栈不为空时：
   - 弹出栈顶元素，并访问该节点。
   - 将节点的右子节点（如果有）压入栈。
   - 将节点的左子节点（如果有）压入栈。
4. 重复步骤3，直到栈为空。

中序遍历（In-order）

1. 创建一个空栈。
2. 从根节点开始，遍历节点的左子树，并将节点压入栈中，直至左子树为空。
3. 当栈不为空时：
   - 弹出栈顶元素，并访问该节点。
   - 转向该节点的右子树并重复步骤2和3。

后序遍历（Post-order）

1. 创建两个栈。
2. 将根节点压入第一个栈中。
3. 当第一个栈不为空时：
   - 弹出一个元素，压入第二个栈中。
   - 将该节点的左子节点和右子节点压入第一个栈中。
4. 依次弹出第二个栈中的元素并访问。

非递归算法实现遍历的代码实现：

见`Traverse Binary Tree with Non Recrusion.cpp`文件

### 二叉树的应用I：表达式树（Expression Tree）

#### 表达式树的基本概念

- 表达式树是一种特殊的二叉树，用于表示数学算术表达式。
- 在这种树中，每个叶节点代表一个数值（如常数），而每个内部节点代表一个运算符（如`+`、`-`、`*`、`/`）。

#### 关于表达式树的相关知识

1. **构建方式**：
   - 对于单个常数，表达式树是一个单节点树，节点即为该常数。
   - 对于包含多个常数和运算符的表达式，将表达式递归地分解成`(expr_left) op (expr_right)`的形式，其中`op`是运算符，`expr_left`和`expr_right`分别是左右子表达式。
   - 在树中，运算符`op`成为内部节点，而`expr_left`和`expr_right`分别构成该节点的左右子树。

2. **遍历与表达式表示**：
   - **前序遍历（根-左-右）**：生成前缀表示法的表达式。
   - **中序遍历（左-根-右）**：生成中缀表示法的表达式，但需要适当加括号以保持运算优先级，否则可能不代表正确的表达式。
   - **后序遍历（左-右-根）**：生成后缀表示法的表达式。

3. **括号的重要性**：
   - 在使用中序遍历表达中缀形式时，必须正确使用括号以保证表达式的意义明确。这是因为不同运算符具有不同的优先级。

4. **应用场景**：
   - 表达式树在编译器设计、算术表达式处理、符号计算等领域中非常重要，它帮助我们理解和操作复杂的算术表达式。

5. **代码实现**:
   - 打印带有冗余括号的中缀表达式。见`Print Infix Expression.cpp`文件。

### 二叉树的应用II：奇偶树（Odd-Even Tree）

#### 奇偶树的基本概念

奇偶树（Odd-Even Tree）是一种特殊的二叉树。在这种树中，所有位于奇数层（第 1 层、第 3 层等）的节点存储的元素必须是奇数，而所有位于偶数层（第 2 层、第 4 层等）的节点存储的元素必须是偶数。

#### 层序遍历判断奇偶树

**具体实现步骤：**

1. 使用两个队列，一个用于存储节点，另一个用于存储节点所在的层级。
2. 将根节点和层数 1 加入对应的队列。
3. 循环执行以下步骤，直到节点队列为空：
   - 从队列中弹出一个节点和它的层数。
   - 检查节点值和层数的奇偶性是否一致。如果不一致，返回 `false`。
   - 如果有左子节点或右子节点，将它们及其层数（当前节点层数+1）加入队列。

**代码实现：**

见`Odd-Even Tree inOrder.cpp`文件。

#### 前序遍历判断奇偶树

**具体实现步骤：**

1. 从根节点开始，递归遍历树的每个节点。
2. 在每个节点，检查其值和传入的层数的奇偶性是否一致。如果不一致，返回 `false`。
3. 递归调用左右子节点，层数加1。

**代码实现：**

见`Odd-Even Tree preOrder.cpp`文件。

#### 一种特殊的奇偶树

二叉树的每一层不仅符合奇偶性，而且节点的值从左到右是递增的。

#### 层序遍历方法判断该特殊奇偶树

见`Special OE Tree inOrder.cpp`文件。

前序遍历法不太适合。

### 二叉树的应用III：二叉树的序列化（Serialization）与反序列化（Deserialization）

#### 二叉树的序列化与反序列化是什么？

**序列化（Serialization）** 是将二叉树的结构转换成一个线性序列的过程。这个过程通过遍历二叉树（如前序遍历、层序遍历）来实现，将每个结点的数据按遍历顺序输出，形成一个线性序列。

**反序列化（Deserialization）** 是序列化的逆过程，即根据线性序列重构出原始的二叉树结构。这个过程依赖于序列化时采用的遍历方案。

#### 序列化与反序列化的问题？

在序列化过程中，需要考虑如何有效表示空结点，以确保在反序列化时能准确重构出原始二叉树。例如，完全二叉树的顺序存储虽然可以作为一种序列化方案，但对于非完全二叉树，这种方法可能会造成空间浪费。

#### 如何进行序列化与反序列化？

使用特殊符号（如`#`）表示空结点。在前序遍历进行序列化的过程中，当遇到空结点或空子树时，输出`#`来标记。在反序列化中，使用了迭代器和递归来模拟遍历过程，并在遇到`#`时创建空结点。

#### 前序遍历下序列化与反序列化代码实现

见`Serialization & Deserialization.cpp`文件。

#### 前序+中序遍历重构二叉树

**重构条件：**

1. **唯一性条件**：在树中没有重复的元素前提下，二叉树的前序遍历和中序遍历结果可以**唯一**确定一棵二叉树。

2. **前序遍历的第一个元素是根节点**：在前序遍历中，第一个访问的元素总是树的根节点。

3. **中序遍历中根节点的位置将树分为左右子树**：在中序遍历中，根节点的位置左侧是左子树的所有节点，右侧是右子树的所有节点。

**算法步骤：**

1. **确定根节点**：从前序遍历中取出第一个元素作为根节点。

2. **在中序遍历中找到根节点的位置**：这将中序遍历序列分为两部分，左侧部分对应左子树，右侧部分对应右子树。

3. **递归构建左右子树**：使用中序遍历中的左侧部分和前序遍历中对应的部分来构建左子树，同理，使用右侧部分来构建右子树。

**时间复杂度分析：**

1. **递归调用次数**：每个节点都需要递归调用一次，因此递归调用的总次数与树中的节点数相同，记为\( n \)。

2. **每次递归的操作**：每次递归主要操作是在中序遍历序列中查找根节点的位置。如果使用线性搜索，每次查找的时间复杂度为\( O(n) \)。

因此，总的时间复杂度是\( O(n^2) \)。但如果使用哈希表先存储中序遍历中每个元素的索引，可以将每次查找的时间复杂度降低到\( O(1) \)，这样总的时间复杂度会降低到\( O(n) \)。

**代码实现（使用Hash Table）：**

```cpp
TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
    unordered_map<int, int> inMap;
    for (int i = 0; i < inorder.size(); i++) {
        inMap[inorder[i]] = i;
    }
    return buildTree(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1, inMap);
}

TreeNode* buildTree(vector<int>& preorder, int pStart, int pEnd, vector<int>& inorder, int iStart, int iEnd, unordered_map<int, int>& inMap) {
    if (pStart > pEnd || iStart > iEnd) return nullptr;
    TreeNode* root = new TreeNode(preorder[pStart]);
    int inRoot = inMap[root->val];
    int numsLeft = inRoot - iStart;

    root->left = buildTree(preorder, pStart + 1, pStart + numsLeft, inorder, iStart, inRoot - 1, inMap);
    root->right = buildTree(preorder, pStart + numsLeft + 1, pEnd, inorder, inRoot + 1, iEnd, inMap);
    return root;
}
```

## 哈夫曼树（Huffman Tree）

### 哈夫曼树基本概念

1. **带权二叉树：**
带权二叉树是一种特殊的二叉树，其中每个叶结点都有一个权重值。这个权重通常表示为正数，代表了该结点的“重要性”或“频率”。在带权二叉树中，我们不仅关注结点的位置，还关注它们的权重。

2. **叶结点的带权路径长度：**
在带权二叉树中，每个叶结点的带权路径长度是一个关键概念。这个长度是叶结点的权重（\(\omega_i\)）与从根结点到该叶结点的路径长度（\(l_i\)）的乘积。路径长度指的是从根结点到叶结点之间经过的分支数，或者可以理解为树的层数。因此，叶结点的带权路径长度可以表达为 \(\omega_i \times l_i\)。

3. **树的带权路径长度（WPL）：**
树的带权路径长度是该树中所有叶结点的带权路径长度之和。它是衡量整棵树带权路径长度效率的一个重要指标。在不同的带权二叉树中，这个值可能不同。

4. **最优二叉树/哈夫曼树**
最优二叉树，也称为哈夫曼树（Huffman Tree），是在所有可能的带权二叉树中，带权路径长度最小的一棵树。构建哈夫曼树的主要目的是为了确保树的带权路径长度尽可能地小。这种树在数据压缩等领域中非常有用，因为它提供了一种高效的数据表示方式。

### 哈夫曼树的基本性质

1. **最优二叉树是满二叉树**：在哈夫曼树中，每个非叶子结点恰有两个子结点。这意味着这种树在每个层级都是“满”的，即除了叶子结点外，每个结点都有两个子结点。

2. **权重不同的叶结点的层级关系**：在最优二叉树中，如果两个叶结点的权重值不同，则权重值较小的叶结点在树中的层数大于或等于权重值较大的叶结点的层数。这是因为哈夫曼树在构建过程中，总是优先将权重较小的结点置于更深的层次，从而保证总的路径长度最小。

3. **权重最小和次小的叶结点位置**：在给定一组叶结点权重的情况下，构建的哈夫曼树会保证权重最小和次小的叶结点位于树的最下层，并且这两个结点互为兄弟结点。这是哈夫曼树构建算法的一个直接结果，因为在构建过程中，总是将当前权重最小的两个结点合并为一个新结点，这两个权重最小的结点自然就会成为兄弟结点，并位于树的最下层。

### 哈夫曼算法

哈夫曼算法是一种构建最优二叉树（哈夫曼树）的有效方法。这个算法是自下而上的过程，通过不断合并带权二叉树来生成哈夫曼树。下面是算法的详细步骤：

#### 哈夫曼算法步骤

1. **初始化**：对于给定的一组权重 \( w_1, w_2, \ldots, w_n \)（其中 \( n \geq 2 \)），首先创建 \( n \) 个只有一个结点的二叉树集合 \( T = \{ T_1, T_2, \ldots, T_n \} \)。这里，每个 \( T_j \) 是一个只包含一个叶结点的二叉树，其根（也是叶子）的权重为 \( w_j \)（对应 \( 1 \leq j \leq n \)）。

2. **合并过程**：
   - 创建一个新的结点。
   - 从集合 \( T \) 中选取根结点权重最小和次小的两个二叉树，分别作为新结点的左右子树。
   - 设置新结点的权重为其左右子树的根结点权重之和。

3. **更新集合**：将步骤 2 中构成的新二叉树插入到集合 \( T \) 中。

4. **重复过程**：重复步骤 2 和 3，直到集合 \( T \) 中只剩下一个二叉树。这个剩下的二叉树就是构建好的哈夫曼树。

#### 哈夫曼算法核心要点

- **权重处理**：在哈夫曼算法中，中间结点的权重等于它的左右子结点权重之和。这保证了每次合并都是在处理当前最小的权重值，进而保证了最终哈夫曼树的最优性。

- **优先队列**：在实际的实现中，通常使用优先队列（如最小堆）来存储和管理这些树，以便高效地找到权重最小和次小的树。

- **最终树的特性**：构建出的哈夫曼树将具有最小的带权路径长度（WPL），这是算法的主要目标。

#### 哈夫曼算法代码实现

见`Create Huffman Tree.cpp`文件。

### 哈夫曼树的应用I：哈夫曼编码

#### 编码的基本概念

在计算机中，所有的数据都是以二进制的形式存储和传输的。对于文本数据，如字符串，我们需要将其转换为二进制编码。这里有两种基本的编码方法：

- **定长码**：每个字符都被转换为固定长度的二进制字符串。例如，如果我们有5个字符（a, b, c, w, z），我们可以使用3位二进制来表示每个字符（如a–000, b–001等）。

- **不定长码**：字符根据其出现频率采用不同长度的编码。高频率的字符使用较短的编码，低频率的字符使用较长的编码。这种方法可以提高编码的效率。

#### 哈夫曼编码

哈夫曼编码是一种使用**不定长码**对数据进行编码的方法，它根据字符出现的频率来构建最优的前缀码。前缀码是一种特殊的不定长码，其中任何字符的编码都不是其他字符编码的前缀。这个特性避免了解码时的歧义。

#### 构建前缀码树

为了构建哈夫曼编码，我们首先统计字符串中每个字符的频率，然后使用这些频率构建一棵哈夫曼树。在这棵树中：

- 每个叶结点代表一个字符。
- 左分支代表0，右分支代表1。
- 从根到叶结点的路径定义了字符的编码。
- 叶结点的深度决定了编码的长度。

![Huffman Encoder](images/Huffman%20Encoder.png)

#### 编码效率

相比于定长码，哈夫曼编码（不定长码）通常更加高效，即编码的位数要少很多。

#### 解码哈夫曼编码

由于哈夫曼编码是前缀码，我们可以唯一地从编码的二进制字符串中恢复原始文本，无需担心歧义。

### 哈夫曼树的应用II：多路合并

#### 多路合并问题描述

假设我们有 \( n \) 个升序序列 \( A_1, A_2, \ldots, A_n \)，需要将它们合并成一个单一的升序序列。合并两个序列的成本（比如比较次数）假定为这两个序列的长度之和。我们的目标是找到一种合并方案，使得总的比较次数最少。

#### 两种合并方案：同步归并和按序合并

- **同步归并**：这种方法涉及查找所有序列中的最小元素，并将其添加到合并序列中。尽管这种方法直观，但它的效率不是最优的，特别是当序列数 \( n \) 较大时，因为每次查找最小元素都需要比较所有序列的头元素。

- **按序合并（两两合并）**：这种方法涉及选择两个序列进行合并，然后重复这个过程，直到所有序列合并成一个。这个过程可以用一棵二叉树来表示，其中每个节点代表一个序列，节点的权重表示序列的长度。

#### 哈夫曼树在多路合并中的应用

哈夫曼树可以用来找到最优的合并顺序，从而最小化总的比较次数。这是通过以下步骤实现的：

- **构建归并二叉树**：每个叶节点代表一个序列，其权重为序列的长度。每个中间节点代表两个子序列的合并，其权重等于子序列长度之和，也就是合并这两个子序列所需的比较次数。

- **计算总比较次数**：合并所有序列的总比较次数等于归并二叉树中所有中间节点的权重和，这实际上是树的带权路径长度（WPL）。

- **哈夫曼算法**：通过应用哈夫曼算法，我们可以构建一棵最优的归并二叉树，使得总的比较次数（即WPL）最小。

#### 两种合并方案效率对比

与同步归并相比，使用哈夫曼树进行的多路合并通常更加高效。这是因为哈夫曼树能够保证在整个合并过程中，每次合并的都是当前最“轻”（即长度最短）的两个序列，从而减少了总的比较次数。
