# The Storage of Graph

## 图存储的两种方式

| 特点/存储法          | 邻接矩阵                               | 邻接表                                      |
|---------------------|----------------------------------------|-------------------------------------------|
| **空间效率**         | 较低，需要为每一对顶点分配空间           | 较高，只为存在的边分配空间                   |
| **存储方式**         | 二维矩阵                               | 一维数组（顶点表）+ 链表（边表）              |
| **适用场景**         | 稠密图，顶点多且边也多                 | 稀疏图，边相对顶点较少                       |
| **边的检索效率**     | 高，可以直接通过矩阵索引访问           | 低，可能需要遍历链表                          |
| **添加/删除边的效率** | 高，直接修改矩阵元素                   | 取决于链表操作，一般较低                       |
| **添加/删除顶点的效率** | 低，需要重新构造整个矩阵               | 较高，只需修改顶点表和相关链表                |
| **存储边的信息**     | 每对顶点间的关系都有存储（即使没有边） | 只存储实际存在的边                            |
| **图的类型表示**     | 无向图的邻接矩阵是对称的               | 无向图中，每条边在两个顶点的链表中各出现一次   |
| **计算顶点的度**     | 直接计算                               | 出度容易计算（遍历边表），入度计算较困难       |

### 邻接矩阵存储法（Adjacency Matrix）

邻接矩阵是表示图中顶点之间的关系的一种方法。在这种存储结构中，我们使用**一维数组**来存放顶点，用一个**二维矩阵**来表示顶点间的边。

- **数组定义**：如果图中有`n`个顶点，我们定义一个`n x n`的矩阵，矩阵的每个元素表示两个顶点之间是否有边。
- **元素表示**：矩阵中的元素`a[i][j]`表示顶点`i`到顶点`j`是否存在一条边。
  - 对于非加权图，如果`i`和`j`之间有边，`a[i][j] = 1`；如果没有边，`a[i][j] = 0`。
  - 对于加权图，`a[i][j]`可以表示`i`和`j`之间边的权重。
- **特点**：
  - 对于无向图，邻接矩阵是对称的（以主对角线）。即`a[i][j] = a[j][i]`。
  - 对于简单图，主对角线上元素`a[i][i] = 0`，即顶点到自身没有边相连。

![Adjacency Matrix 1](images/Adjacency%20Matrix%201.png)

![Adjacency Matrix 2](images/Adjacency%20Matrix%202.png)

#### 邻接矩阵存储图各项操作的时间复杂度

| 操作                   | 时间复杂度    | 解释                                                         |
|------------------------|------------|--------------------------------------------------------------|
| 检查两个顶点是否相邻（有无边连接）          | \( O(1) \) | 通过直接访问矩阵的对应元素来确定两个顶点是否相邻。                    |
| 查找给定顶点的所有邻居（计算结点的度）        | \( O(n) \) | 遍历矩阵中给定顶点对应的行或列，找到所有的邻居。                         |
| 查找度最大的结点            | \( O(n^2) \) | 需要遍历矩阵的每一行，计算所有顶点的度，然后找出度最大的顶点。              |
| 添加或删除一个顶点          | \( O(?) \) | 添加或删除顶点涉及到矩阵维度的变化，需要重新构造整个矩阵。                   |
| 添加或删除一条边            | \( O(1) \) | 直接修改两个顶点对应的矩阵元素即可添加或删除一条边。                        |

#### 加权邻接矩阵（Weighted Adjacency Matrix）

- 矩阵的行和列对应图中的顶点。
- 矩阵中的元素表示顶点之间边的权重。
  - 如果顶点`i`和`j`之间存在边，则`a[i][j]`表示这条边的权重。
  - 如果顶点`i`和`j`之间没有边，则`a[i][j]`通常设置为一个非常大的数（例如`∞`），或者在某些实现中，可能设置为一个特殊的标记值，以表示这两个顶点之间没有直接的连接。
- 对于无向加权图，邻接矩阵是对称的，即`a[i][j]`和`a[j][i]`相等，因为边是无向的，从`i`到`j`的权重与从`j`到`i`的权重是相同的。
- 对于自环（即顶点到自己的边），如果允许自环存在，它们会在主对角线上表示，即`a[i][i]`表示顶点`i`的自环的权重。其它情况下，该值一般设为\(0\)。

![Weighted Adjacency Matrix](images/Weighted%20Adjacency%20Matrix.png)

#### 邻接矩阵与加权邻接矩阵的优缺点

##### 邻接矩阵的优点

1. **快速查找边的存在性**：判断任意两个顶点之间是否存在边非常容易，只需要查看矩阵中相应的元素即可，时间复杂度为 \( O(1) \)。
2. **快速修改边的信息**：在两个顶点之间添加或删除边非常容易，直接修改矩阵对应的元素即可，操作时间复杂度也是 \( O(1) \)。
3. **易于计算顶点的度数**：对于无向图，顶点的度就是邻接矩阵中相应行（或列）非零元素的个数；对于有向图，顶点的出度是行的非零元素的个数，入度是列的非零元素的个数。

##### 邻接矩阵的缺点

1. **空间效率低**：当边的总数远远小于 \( n^2 \) 时，依然需要 \( n^2 \) 个内存单元来存储边的信息，这在稀疏图（边相对较少）中造成了巨大的空间浪费。
2. **不适合大规模稀疏图**：对于大规模的稀疏图，邻接矩阵会占用大量内存，但实际上很多内存位置是不会被使用的。

##### 加权邻接矩阵的优点

1. **直接表示边的权重**：加权邻接矩阵可以直接存储边的权重信息，这对于算法（如最短路径算法）来说是必要的。
2. **统一表示有权和无权图**：即便是非加权图，也可以通过赋予边统一的权重（如1）来使用加权邻接矩阵表示。

##### 加权邻接矩阵的缺点：

1. **初始化复杂度高**：对于不存在的边，需要初始化一个较大的数或特殊值（如无穷大），这在某些实现中可能需要额外的逻辑处理。
2. **权重更新成本高**：如果图中边的权重经常变动，每次变动都需要更新矩阵，这可能导致频繁的计算和存储操作。

综上所述，邻接矩阵和加权邻接矩阵在表示图的连接关系方面非常直观有效，特别是在图的边相对密集，且边的添加和删除操作频繁的情况下。但它们在空间效率上表现不佳，尤其是对于大规模的稀疏图。在实际应用中，选择使用邻接矩阵还是其他图的表示方法（如邻接表），需要根据图的特性和操作的需求来决定。