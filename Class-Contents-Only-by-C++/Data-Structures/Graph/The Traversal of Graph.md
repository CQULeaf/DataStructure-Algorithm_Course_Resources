# The Traversal of Graph

## 概述

### 什么是图的遍历

图的遍历是指在图（Graph）这一数据结构中，按照某种规则系统地访问图中的每一个顶点，而且保证每一个顶点仅被访问一次。图遍历的主要目的是为了发现图的属性，如检查图中是否存在路径、环路、连接的各个部分等。

### 图的两种遍历方法概述

[两种遍历方法的概念讲授](https://www.bilibili.com/video/BV1T64y147r1?vd_source=b8f0cc4acb2951ad6eaeaee5256727aa)

图遍历的两种主要方法是**深度优先搜索（Depth-First Search, DFS）**和**广度优先搜索（Breadth-First Search, BFS）**。

1. **深度优先搜索（DFS）**：这种方法会尽可能深地搜索图的分支。DFS 会从图的一个未被访问的顶点开始，沿着一条路径走到底，直至没有未访问的相邻节点为止，然后回溯继续搜索下一条路径。DFS 通常用**递归**（Recursion）或**栈**（Stack）实现。

2. **广度优先搜索（BFS）**：这种方法会从图的一个未被访问的顶点开始，访问所有相邻的顶点，然后对每一个相邻的顶点重复同样的过程。BFS 通常用**队列**（Queue）来实现。

下面是DFS与BFS的对比表格：

| 特点 | 深度优先搜索（DFS） | 广度优先搜索（BFS） |
| --- | --- | --- |
| 搜索顺序 | 深入图的分支直到不可再深 | 按层遍历图中顶点 |
| 数据结构 | 栈（Stack）或递归（Recursion） | 队列（Queue） |
| 应用场景 | 寻找**全部方案**，如迷宫的所有路径 | 寻找**最短路径**，如在社交网络中寻找最短连接路径 |
| 空间复杂度 | \(O(V)\)，V为顶点数 | \(O(V)\)，V为顶点数 |
| 时间复杂度 | \(O(V+E)\)，V为顶点数，E为边数 | \(O(V+E)\)，V为顶点数，E为边数 |
| 特点 | 适合目标比较明确，要求全面搜索的情况 | 适合求解最短路径或接近问题 |

### 图的遍历与树的遍历对比

| 特点 | 图的遍历 | 二叉树的遍历 |
| ---- | ------- | ---------- |
| **顶点地位** | 所有顶点地位相同，无特殊顶点 | 有一个特殊的根结点 |
| **顶点的邻接关系** | 一个顶点可能与多个其他顶点邻接，可能有多个直接前驱和后继，可能存在回路 | 每个结点的直接前驱最多一个，直接后继最多两个（左右子结点），无回路 |
| **边的邻接关系** | 无向图中，邻接边的两个顶点可视作互为后继 | 不适用，因为二叉树的边代表父子关系 |
| **避免重复访问** | 需要特殊标记防止重复访问，因为可能存在环路 | 通常不需要特殊标记，因为无环路 |

## BFS & DFS 算法代码实现

### BFS基本算法思想

[详细讲解图的BFS代码实现](https://www.bilibili.com/video/BV1s5411M7vz?vd_source=b8f0cc4acb2951ad6eaeaee5256727aa)

广度优先搜索（Breadth-First Search, BFS）是一种用于遍历或搜索图的算法。它的基本思想是从一个起始顶点开始，先访问所有与之相邻的顶点，再逐层向外扩展，直到所有可达的顶点都被访问到。BFS 通常使用**队列**来实现这种层次遍历。

BFS 算法实现大致步骤：

1. **初始化队列**：首先，将起始顶点放入队列中。

2. **遍历队列**：当队列不为空时，进行遍历：
   - 从队列中弹出一个顶点。
   - 访问该顶点，并执行相关操作（比如打印顶点、检查顶点属性等）。
   - 将所有未访问过且与当前顶点相邻的顶点加入队列，并标记为已访问。

3. **重复过程**：重复步骤2，直到队列为空。

关键点：

- **使用队列**：BFS 使用队列数据结构（FIFO）来保持待访问顶点的顺序，确保每次都是从最早加入队列的顶点开始扩展。
- **标记已访问顶点**：为了防止一个顶点被重复访问（尤其是在图中），需要对已经访问过的顶点进行标记。

通过这种方式，BFS 能够按照从近到远的顺序访问图中的每个顶点且 BFS 特别适合用于找到从起点到其他顶点的最短路径（在边权重相同的情况下）。

