# The Traversal of Graph

## 概述

### 什么是图的遍历

图的遍历是指在图（Graph）这一数据结构中，按照某种规则系统地访问图中的每一个顶点，而且保证每一个顶点仅被访问一次。图遍历的主要目的是为了发现图的属性，如检查图中是否存在路径、环路、连接的各个部分等。

### 图的两种遍历方法概述

[两种遍历方法的概念讲授](https://www.bilibili.com/video/BV1T64y147r1?vd_source=b8f0cc4acb2951ad6eaeaee5256727aa)

图遍历的两种主要方法是**深度优先搜索（Depth-First Search, DFS）**和**广度优先搜索（Breadth-First Search, BFS）**。

1. **深度优先搜索（DFS）**：这种方法会尽可能深地搜索图的分支。DFS 会从图的一个未被访问的顶点开始，沿着一条路径走到底，直至没有未访问的相邻节点为止，然后回溯继续搜索下一条路径。DFS 通常用**递归**（Recursion）或**栈**（Stack）实现。

2. **广度优先搜索（BFS）**：这种方法会从图的一个未被访问的顶点开始，访问所有相邻的顶点，然后对每一个相邻的顶点重复同样的过程。BFS 通常用**队列**（Queue）来实现。

下面是DFS与BFS的对比表格：

| 特点 | 深度优先搜索（DFS） | 广度优先搜索（BFS） |
| --- | --- | --- |
| 搜索顺序 | 深入图的分支直到不可再深 | 按层遍历图中顶点 |
| 数据结构 | 栈（Stack）或递归（Recursion） | 队列（Queue） |
| 应用场景 | 寻找**全部方案**，如迷宫的所有路径 | 寻找**最短路径**，如在社交网络中寻找最短连接路径 |
| 空间复杂度 | \(O(V)\)，V为顶点数 | \(O(V)\)，V为顶点数 |
| 时间复杂度 | \(O(V+E)\)，V为顶点数，E为边数 | \(O(V+E)\)，V为顶点数，E为边数 |
| 特点 | 适合目标比较明确，要求全面搜索的情况 | 适合求解最短路径或接近问题 |

### 图的遍历与树的遍历对比

| 特点 | 图的遍历 | 二叉树的遍历 |
| ---- | ------- | ---------- |
| **顶点地位** | 所有顶点地位相同，无特殊顶点 | 有一个特殊的根结点 |
| **顶点的邻接关系** | 一个顶点可能与多个其他顶点邻接，可能有多个直接前驱和后继，可能存在回路 | 每个结点的直接前驱最多一个，直接后继最多两个（左右子结点），无回路 |
| **边的邻接关系** | 无向图中，邻接边的两个顶点可视作互为后继 | 不适用，因为二叉树的边代表父子关系 |
| **避免重复访问** | 需要特殊标记防止重复访问，因为可能存在环路 | 通常不需要特殊标记，因为无环路 |

## BFS & DFS 算法代码实现

### BFS基本算法思想

[详细讲解图的BFS代码实现](https://www.bilibili.com/video/BV1s5411M7vz?vd_source=b8f0cc4acb2951ad6eaeaee5256727aa)

广度优先搜索（Breadth-First Search, BFS）是一种用于遍历或搜索图的算法。它的基本思想是从一个起始顶点开始，先访问所有与之相邻的顶点，再逐层向外扩展，直到所有可达的顶点都被访问到。BFS 通常使用**队列**来实现这种层次遍历。

BFS 算法实现大致步骤：

1. **初始化队列**：首先，将起始顶点放入队列中。

2. **遍历队列**：当队列不为空时，进行遍历：
   - 从队列中弹出一个顶点。
   - 访问该顶点，并执行相关操作（比如打印顶点、检查顶点属性等）。
   - 将所有未访问过且与当前顶点相邻的顶点加入队列，并标记为已访问。

3. **重复过程**：重复步骤2，直到队列为空。

关键点：

- **使用队列**：BFS 使用队列数据结构（FIFO）来保持待访问顶点的顺序，确保每次都是从最早加入队列的顶点开始扩展。
- **标记已访问顶点**：为了防止一个顶点被重复访问（尤其是在图中），需要对已经访问过的顶点进行标记。

通过这种方式，BFS 能够按照从近到远的顺序访问图中的每个顶点且 BFS 特别适合用于找到从起点到其他顶点的最短路径（在边权重相同的情况下）。

### BFS代码实践

```cpp
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

// 这个类表示使用邻接表的有向图
class Graph {
    int V;  // 顶点的数量
    vector<vector<int>> adj; // 邻接表

public:
    Graph(int V) {
        this->V = V;
        adj.resize(V);
    }

    void addEdge(int v, int w) {
        adj[v].push_back(w); // 在v的列表中添加w
    }

    void BFS(int s) {
        vector<bool> visited(V, false); // 标记所有顶点为未访问
        queue<int> queue; // 为BFS创建一个队列

        visited[s] = true; // 标记当前节点为已访问并入队
        queue.push(s);

        while (!queue.empty()) {
            s = queue.front();
            cout << s << " ";
            queue.pop();

            for (int adjacent : adj[s]) {
                if (!visited[adjacent]) {
                    visited[adjacent] = true;
                    queue.push(adjacent);
                }
            }
        }
    }
};

int main() {
    Graph g(4);
    g.addEdge(0, 1);
    g.addEdge(0, 2);
    g.addEdge(1, 2);
    g.addEdge(2, 0);
    g.addEdge(2, 3);
    g.addEdge(3, 3);

    cout << "下面是从顶点2开始的广度优先遍历(Breadth First Traversal)\n";
    g.BFS(2);

   system("pause");
    return 0;
}
```

### DFS基本算法思想

[详细讲解图的DFS代码实现](https://b23.tv/XWotFVJ)

深度优先搜索（Depth-First Search, DFS）是一种用于遍历或搜索树或图的算法。与广度优先搜索不同，深度优先搜索的核心思想是尽可能深地搜索图的分支。

DFS 算法实现大致步骤：

1. **选择起始点**：从一个顶点开始，作为搜索的起始点。

2. **探索未访问的分支**：
   - 访问当前顶点，并进行标记为已访问。
   - 查找当前顶点的所有邻接顶点，对于每一个未访问的邻接顶点，继续进行深度优先搜索。

3. **回溯**：当当前顶点的所有邻接顶点都已访问或没有邻接顶点时，回溯到上一个顶点，继续执行步骤2。

4. **重复过程**：重复步骤2和3，直到所有可达的顶点都被访问到。

关键点：

- **递归实现**：DFS 通常通过**递归**来实现。在每一层递归中，选择一个邻接顶点进行探索，直到无法继续为止。
- **使用栈**：除了递归，DFS 也可以使用**栈**来实现。在这种实现中，利用栈保存待访问的顶点。
- **标记已访问顶点**：为了避免重复访问同一顶点，需要对已访问的顶点进行标记。

DFS 的这种深入探索的特性使它非常适合于需要深度遍历的场景，如寻找所有可能的解决方案，检测环路，或者在图中搜索从一个顶点到另一个顶点的路径。由于它会尽可能深地探索，直到无法继续为止，然后回溯，因此它也适用于找到路径或者解决方案的所有可能性。

### DFS代码实现

```cpp
#include <iostream>
#include <unordered_map>
#include <list>
using namespace std;

class Graph {
public:
    unordered_map<int, bool> visited;// 用于标记顶点是否已被访问
    unordered_map<int, list<int>> adj;// 邻接表

    void addEdge(int v, int w) {
        adj[v].push_back(w);
    }

    void DFS(int v) {
        visited[v] = true;
        cout << v << " ";

        for (int adjacent : adj[v]) {
            if (!visited[adjacent]) {
                DFS(adjacent);
            }
        }
    }
};

int main() {
    Graph g;
    g.addEdge(0, 1);
    g.addEdge(0, 2);
    g.addEdge(1, 2);
    g.addEdge(2, 0);
    g.addEdge(2, 3);
    g.addEdge(3, 3);

    cout << "下面是从顶点2开始的深度优先遍历(Depth First Traversal)\n";
    g.DFS(2);

    system("pause");
    return 0;
}
```

**注意：**

- DFS可以通过使用栈来实现非递归版本，栈用于明确地维护访问过程中的回溯路径。但在我们这个递归实现中，这种回溯是隐式的，由函数调用栈（function call stack）管理。每次递归调用DFS相当于在函数调用栈上“压入”一个新的层级，而当递归调用完成返回时，相当于从栈中“弹出”这个层级。

- 在我们这个递归实现过程中，将不会直接看到一个栈的数据结构，因为递归本身就是通过函数调用栈来实现的。递归实现通常更简洁，但在深度很大的图中可能导致栈溢出。而非递归实现（显式使用栈）可以避免这个问题，但代码通常更复杂。所以如果我们需要处理非常大的图或者想避免递归导致的栈溢出问题，可以考虑使用显式栈的非递归实现。

#### `unordered_map` VS `vector`

注意到，在BFS代码实现中我们用`vector`这一数据结构来存储图，而在DFS代码实现中我们用`unordered_map`来存储图。实际上，在实现BFS和DFS时，选择哪种数据结构来存储图（如`unordered_map`或`vector`）主要取决于图本身的特性以及特定的应用需求，而没有固定的要求，我们可以根据需要灵活选择。

下面是两者的对比：

| **特性/考量**         | **unordered_map**                                                                                                 | **vector**                                                                                           |
|-------------------|---------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------|
| **数据结构类型**     | 关联容器，基于哈希表实现。                                                                                           | 序列容器，提供快速的顺序访问。                                                                           |
| **访问速度**         | 平均情况下访问时间为\(O(1)\)，但最坏情况下为\(O(n)\)。                                                                       | 访问时间总是\(O(1)\)。                                                                                  |
| **内存分布**         | 内存分布不连续。                                                                                                | 内存分布连续。                                                                                      |
| **顶点编号连续性**    | 适合处理顶点编号不连续或未知的图。                                                                                    | 适合处理顶点编号连续且数量已知的图。                                                                     |
| **动态性**          | 可以动态地添加和删除顶点和边，更适合于动态变化的图。                                                                   | 在图结构固定时更有效，对动态变化的图可能不够灵活。                                                         |
| **适用场景**        | 适用于复杂或大型图，特别是当顶点和边的添加/删除操作频繁时。                                                              | 适用于结构简单、顶点数量固定的图。                                                                     |
| **性能考虑**        | 由于基于哈希表，性能可能受哈希函数和冲突处理机制的影响。                                                               | 由于内存连续，可以提供高效的缓存利用率，但可能在大型图中因为内存重新分配而影响性能。                            |
| **初始化复杂性**     | 不需要提前知道顶点数量，更易于处理图的动态变化。                                                                        | 需要预先知道顶点数量以分配内存，适用于静态图。                                                           |
