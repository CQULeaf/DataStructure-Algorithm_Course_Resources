# 线性表

## 线性表的概念掌握

### 线性表的定义

线性表（Linear List）是由同一类型的数据元素构成的有序序列的线性结构。除了首尾元素外，每个元素有且仅有一个前驱和一个后继。线性表常用于表示具有一对一关系的数据集合，可以通过数组（Array）或链表（Linked List）等方式实现。

### 线性表的结构

线性表的结构可以从**逻辑结构**和**物理结构**两个方面来理解。

**线性表的逻辑结构**：
逻辑结构描述的是数据元素之间的逻辑（序列）关系，不涉及具体的物理存储。在线性表的逻辑结构中，每个数据元素（除了第一个和最后一个元素）都有唯一的前驱（Predecessor）和后继（Successor）。这种逻辑结构定义了数据元素之间一对一的线性关系，即它们形成一个序列，这就像我们平时使用的一系列有序排列的数字或者物品。

**线性表的物理结构**：
物理结构，又称为存储结构，是指线性表的逻辑结构在计算机内存中的存储形式。线性表的物理结构主要有两种：

1. **顺序存储结构**：在这种结构中，线性表的数据元素被存储在计算机内存的**连续单元**中。这就意味着表中任意两个相邻的数据元素，**在内存中也是相邻的**。这种物理结构下，可以通过**首元素的存储位置**和**元素的索引**来快速访问任意元素，因此**访问效率高**。**数组**就是顺序存储结构的一个典型例子。

2. **链式存储结构**：与顺序存储不同，链式存储结构中的数据元素可以存储在内存的**任意位置**，每个元素的存储单元称为**结点**。每个结点除了存储**数据元素**外，还存储了一个或多个指向其它结点的**引用**（即指针），这些指针将所有的结点按照线性表的逻辑顺序连接起来。**链表**就是链式存储结构的一个典型例子。

| 存储结构类型 | 优点 | 缺点 | 适用场景 |
|:------------:|:----:|:----:|:--------:|
| 顺序存储结构 | 访问效率高，可以通过索引快速访问任意元素 | 插入和删除操作效率低，可能需要移动大量元素 | 需要频繁访问元素的场景 |
| 链式存储结构 | 插入和删除操作效率高，只需要改变指针指向 | 访问效率低，需要从头结点按顺序遍历 | 插入和删除操作更频繁的场景 |

在考虑使用哪种存储结构时，应该基于实际应用中操作的频率和类型来决定。如果应用中对数据的访问比修改更频繁，则顺序存储结构更为合适；相反，如果应用中数据的插入和删除操作更常见，则链式存储结构可能更优。

### 线性表的ADT

**ADT List** {
    **数据对象：**\( \{a_i | a_i \in ElemSet, i=1,2,...,n, n > 0\} \)或\(\varPhi\) ，即空表；\(ElemSet\)是元素集合。
    **数据关系：**\( \{<a_i, a_{i+1}> | a_i, a_{i+1} \in ElemSet, i=1,2,...,n-1\} \)，即元素之间具有一定的线性关系，元素之间是有序关系。
    **基本操作：**
    - InitList(\(list\))：初始化一个空的线性表\(list\)。
    - DestroyList(\(list\))：销毁已存在的线性表\(list\)，释放占用的资源。
    - Clear(\(list\))：清空线性表\(list\)。
    - IsEmpty(\(list\))：判断线性表\(list\)是否为空表，为空则返回真，不为空则返回假。
    - Length(\(list\))：返回线性表\(list\)的元素个数，即表的长度。
    - Get(\(list, i\))：返回线性表\(list\)中第\(i\)个元素的值。
    - Search(\(list, x\))：在线性表\(list\)中查找元素\(x\)，查找成功，返回其在表中的位置，不成功则返回NIL。
    - Insert(\(list, i, x\))：在线性表\(list\)的第\(i\)个位置上插入一个元素\(x\)。
    - Remove(\(list, i\))：从线性表\(list\)中删除第\(i\)个元素。
}

## 线性表的代码实现&应用

### 使用数组实现的顺序表的基本操作

见`Sequential List Implemented with Arrays.cpp`文件。

### 使用指针实现的链表的基本操作

见`Linked List Implemented with Pointers.cpp`文件。

### 查找长度未知的单链表倒数第\(k\)个节点

#### 单指针法（2次遍历）

代码实现见`Find Kth Node From Bottom (Single Pointer Method).cpp`文件。

解题思想：

1. **第一次遍历**：遍历整个链表以确定链表的长度 \(n\)。
2. **第二次遍历**：再次遍历链表，但这次只遍历到第 \(n-k\) 个结点（从1开始计数）。这个结点即为倒数第\(k\)个结点。

代码思想：

1. **初始化计数器**：设置一个计数器 `count` 为0。

2. **第一次遍历**：
   - 从链表的头节点开始遍历链表。
   - 每访问一个结点，`count` 增加1。
   - 遍历完成后，`count` 将等于链表的总长度 \(n\)。

3. **检查k的有效性**：如果 \(k > n\) 或 \(k <= 0\)，则倒数第k个结点不存在，直接返回。

4. **第二次遍历**：
   - 重置 `current` 指针回到链表头部。
   - 遍历链表，但只到第 \(n-k\) 个结点。
   - 到达第 \(n-k\) 个结点时停止，这个结点就是倒数第k个结点。

5. **返回结果**：返回当前的 `current` 指针指向的结点。

#### 双指针法（1次遍历）

代码实现见`Find Kth Node From Bottom (Double Pointers Method).cpp`文件。

代码思想：

1. **初始化两个指针**：初始化两个指针 `fast` 和 `slow`，都指向链表的头节点。

2. **移动 `fast` 指针**：将 `fast` 指针向前移动 `k` 个节点。这样，`fast` 和 `slow` 之间就相隔 `k` 个节点。

3. **同时移动两个指针**：接着，同时移动 `fast` 和 `slow` 指针，直到 `fast` 指向链表的末尾节点（即 `fast` 的 `next` 指针为 `nullptr`）。由于 `fast` 和 `slow` 之间始终保持 `k` 个节点的距离，当 `fast` 到达链表末尾时，`slow` 正好指向倒数第\(k\)个节点。

4. **返回结果**：返回 `slow` 指针指向的节点，即为所求的倒数第\(k\)个节点。

#### 两种方法的比较

| 特性/方法       | 单指针法               | 双指针法               |
|-----------------|-----------------------|-----------------------|
| 遍历次数         | 两次                   | 一次                   |
| 时间复杂度       | \(O(2n)\) 即 \(O(n)\) | \(O(n)\)              |
| 空间复杂度       | \(O(1)\)              | \(O(1)\)              |
| 实现复杂度       | 简单                   | 略复杂                 |
| 效率             | 较低                   | 较高                   |
| 适用场景         | 链表长度未知时         | 链表长度未知时         |
| 链表长度要求     | 无特殊要求             | 无特殊要求             |
| 对链表长度的检查 | 第一次遍历时检查       | 移动 `fast` 指针时检查 |

