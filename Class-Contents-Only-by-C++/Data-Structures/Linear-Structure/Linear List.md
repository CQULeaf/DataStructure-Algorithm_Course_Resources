# 线性表

## 线性表的定义

线性表（Linear List）是由同一类型的数据元素构成的有序序列的线性结构。除了首尾元素外，每个元素有且仅有一个前驱和一个后继。线性表常用于表示具有一对一关系的数据集合，可以通过数组（Array）或链表（Linked List）等方式实现。

## 线性表的结构

线性表的结构可以从**逻辑结构**和**物理结构**两个方面来理解。

**线性表的逻辑结构**：
逻辑结构描述的是数据元素之间的逻辑（序列）关系，不涉及具体的物理存储。在线性表的逻辑结构中，每个数据元素（除了第一个和最后一个元素）都有唯一的前驱（Predecessor）和后继（Successor）。这种逻辑结构定义了数据元素之间一对一的线性关系，即它们形成一个序列，这就像我们平时使用的一系列有序排列的数字或者物品。

**线性表的物理结构**：
物理结构，又称为存储结构，是指线性表的逻辑结构在计算机内存中的存储形式。线性表的物理结构主要有两种：

1. **顺序存储结构**：在这种结构中，线性表的数据元素被存储在计算机内存的**连续单元**中。这就意味着表中任意两个相邻的数据元素，**在内存中也是相邻的**。这种物理结构下，可以通过**首元素的存储位置**和**元素的索引**来快速访问任意元素，因此**访问效率高**。**数组**就是顺序存储结构的一个典型例子。

2. **链式存储结构**：与顺序存储不同，链式存储结构中的数据元素可以存储在内存的**任意位置**，每个元素的存储单元称为**结点**。每个结点除了存储**数据元素**外，还存储了一个或多个指向其它结点的**引用**（即指针），这些指针将所有的结点按照线性表的逻辑顺序连接起来。**链表**就是链式存储结构的一个典型例子。

| 存储结构类型 | 优点 | 缺点 | 适用场景 |
|:------------:|:----:|:----:|:--------:|
| 顺序存储结构 | 访问效率高，可以通过索引快速访问任意元素 | 插入和删除操作效率低，可能需要移动大量元素 | 需要频繁访问元素的场景 |
| 链式存储结构 | 插入和删除操作效率高，只需要改变指针指向 | 访问效率低，需要从头结点按顺序遍历 | 插入和删除操作更频繁的场景 |

在考虑使用哪种存储结构时，应该基于实际应用中操作的频率和类型来决定。如果应用中对数据的访问比修改更频繁，则顺序存储结构更为合适；相反，如果应用中数据的插入和删除操作更常见，则链式存储结构可能更优。

## 线性表的ADT

**ADT List** {
    **数据对象：**\( \{a_i | a_i \in ElemSet, i=1,2,...,n, n > 0\} \)或\(\varPhi\) ，即空表；\(ElemSet\)是元素集合。
    **数据关系：**\( \{<a_i, a_{i+1}> | a_i, a_{i+1} \in ElemSet, i=1,2,...,n-1\} \)，即元素之间具有一定的线性关系，元素之间是有序关系。
    **基本操作：**
    - InitList(\(list\))：初始化一个空的线性表\(list\)。
    - DestroyList(\(list\))：销毁已存在的线性表\(list\)，释放占用的资源。
    - Clear(\(list\))：清空线性表\(list\)。
    - IsEmpty(\(list\))：判断线性表\(list\)是否为空表，为空则返回真，不为空则返回假。
    - Length(\(list\))：返回线性表\(list\)的元素个数，即表的长度。
    - Get(\(list, i\))：返回线性表\(list\)中第\(i\)个元素的值。
    - Search(\(list, x\))：在线性表\(list\)中查找元素\(x\)，查找成功，返回其在表中的位置，不成功则返回NIL。
    - Insert(\(list, i, x\))：在线性表\(list\)的第\(i\)个位置上插入一个元素\(x\)。
    - Remove(\(list, i\))：从线性表\(list\)中删除第\(i\)个元素。
}

## 线性表的顺序存储实现

直接上C++代码