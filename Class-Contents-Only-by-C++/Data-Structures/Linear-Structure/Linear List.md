# 线性表

## 线性表的概念掌握

### 线性表的定义

线性表（Linear List）是由同一类型的数据元素构成的有序序列的线性结构。除了首尾元素外，每个元素有且仅有一个前驱和一个后继。线性表常用于表示具有一对一关系的数据集合，可以通过数组（Array）或链表（Linked List）等方式实现。

### 线性表的结构

线性表的结构可以从**逻辑结构**和**物理结构**两个方面来理解。

**线性表的逻辑结构**：
逻辑结构描述的是数据元素之间的逻辑（序列）关系，不涉及具体的物理存储。在线性表的逻辑结构中，每个数据元素（除了第一个和最后一个元素）都有唯一的前驱（Predecessor）和后继（Successor）。这种逻辑结构定义了数据元素之间一对一的线性关系，即它们形成一个序列，这就像我们平时使用的一系列有序排列的数字或者物品。

**线性表的物理结构**：
物理结构，又称为存储结构，是指线性表的逻辑结构在计算机内存中的存储形式。线性表的物理结构主要有两种：

1. **顺序存储结构**：在这种结构中，线性表的数据元素被存储在计算机内存的**连续单元**中。这就意味着表中任意两个相邻的数据元素，**在内存中也是相邻的**。这种物理结构下，可以通过**首元素的存储位置**和**元素的索引**来快速访问任意元素，因此**访问效率高**。**数组**就是顺序存储结构的一个典型例子。

2. **链式存储结构**：与顺序存储不同，链式存储结构中的数据元素可以存储在内存的**任意位置**，每个元素的存储单元称为**结点**。每个结点除了存储**数据元素**外，还存储了一个或多个指向其它结点的**引用**（即指针），这些指针将所有的结点按照线性表的逻辑顺序连接起来。**链表**就是链式存储结构的一个典型例子。

| 存储结构类型 | 优点 | 缺点 | 适用场景 |
|:------------:|:----:|:----:|:--------:|
| 顺序存储结构 | 访问效率高，可以通过索引快速访问任意元素 | 插入和删除操作效率低，可能需要移动大量元素 | 需要频繁访问元素的场景 |
| 链式存储结构 | 插入和删除操作效率高，只需要改变指针指向 | 访问效率低，需要从头结点按顺序遍历 | 插入和删除操作更频繁的场景 |

在考虑使用哪种存储结构时，应该基于实际应用中操作的频率和类型来决定。如果应用中对数据的访问比修改更频繁，则顺序存储结构更为合适；相反，如果应用中数据的插入和删除操作更常见，则链式存储结构可能更优。

### 线性表的ADT

**ADT List** {
**数据对象：**\( \{a_i | a_i \in ElemSet, i=1,2,...,n, n > 0\} \)或\(\varPhi\) ，即空表；\(ElemSet\)是元素集合。
**数据关系：**\( \{<a_i, a_{i+1}> | a_i, a_{i+1} \in ElemSet, i=1,2,...,n-1\} \)，即元素之间具有一定的线性关系，元素之间是有序关系。
**基本操作：**

- InitList(\(list\))：初始化一个空的线性表\(list\)。
- DestroyList(\(list\))：销毁已存在的线性表\(list\)，释放占用的资源。
- Clear(\(list\))：清空线性表\(list\)。
- IsEmpty(\(list\))：判断线性表\(list\)是否为空表，为空则返回真，不为空则返回假。
- Length(\(list\))：返回线性表\(list\)的元素个数，即表的长度。
- Get(\(list, i\))：返回线性表\(list\)中第\(i\)个元素的值。
- Search(\(list, x\))：在线性表\(list\)中查找元素\(x\)，查找成功，返回其在表中的位置，不成功则返回NIL。
- Insert(\(list, i, x\))：在线性表\(list\)的第\(i\)个位置上插入一个元素\(x\)。
- Remove(\(list, i\))：从线性表\(list\)中删除第\(i\)个元素。
}

## 线性表的代码实现&应用

### 使用数组实现的顺序表的基本操作

见`Sequential List Implemented with Arrays.cpp`文件。

### 使用指针实现的链表的基本操作

见`Linked List Implemented with Pointers.cpp`文件。

### 查找长度未知的单链表倒数第\(k\)个节点

#### 单指针法（2次遍历）

代码实现见`Find Kth Node From Bottom (Single Pointer Method).cpp`文件。

解题思想：

1. **第一次遍历**：遍历整个链表以确定链表的长度 \(n\)。
2. **第二次遍历**：再次遍历链表，但这次只遍历到第 \(n-k\) 个结点（从1开始计数）。这个结点即为倒数第\(k\)个结点。

代码思想：

1. **初始化计数器**：设置一个计数器 `count` 为0。

2. **第一次遍历**：
   - 从链表的头节点开始遍历链表。
   - 每访问一个结点，`count` 增加1。
   - 遍历完成后，`count` 将等于链表的总长度 \(n\)。

3. **检查k的有效性**：如果 \(k > n\) 或 \(k <= 0\)，则倒数第k个结点不存在，直接返回。

4. **第二次遍历**：
   - 重置 `current` 指针回到链表头部。
   - 遍历链表，但只到第 \(n-k\) 个结点。
   - 到达第 \(n-k\) 个结点时停止，这个结点就是倒数第k个结点。

5. **返回结果**：返回当前的 `current` 指针指向的结点。

#### 双指针法（1次遍历）

代码实现见`Find Kth Node From Bottom (Double Pointers Method).cpp`文件。

代码思想：

1. **初始化两个指针**：初始化两个指针 `fast` 和 `slow`，都指向链表的头节点。

2. **移动 `fast` 指针**：将 `fast` 指针向前移动 `k` 个节点。这样，`fast` 和 `slow` 之间就相隔 `k` 个节点。

3. **同时移动两个指针**：接着，同时移动 `fast` 和 `slow` 指针，直到 `fast` 指向链表的末尾节点（即 `fast` 的 `next` 指针为 `nullptr`）。由于 `fast` 和 `slow` 之间始终保持 `k` 个节点的距离，当 `fast` 到达链表末尾时，`slow` 正好指向倒数第\(k\)个节点。

4. **返回结果**：返回 `slow` 指针指向的节点，即为所求的倒数第\(k\)个节点。

#### 单/双指针法的比较

| 特性/方法       | 单指针法               | 双指针法               |
|-----------------|-----------------------|-----------------------|
| 遍历次数         | 两次                   | 一次                   |
| 时间复杂度       | \(O(2n)\) 即 \(O(n)\) | \(O(n)\)              |
| 空间复杂度       | \(O(1)\)              | \(O(1)\)              |
| 实现复杂度       | 简单                   | 略复杂                 |
| 效率             | 较低                   | 较高                   |
| 适用场景         | 链表长度未知时         | 链表长度未知时         |
| 链表长度要求     | 无特殊要求             | 无特殊要求             |
| 对链表长度的检查 | 第一次遍历时检查       | 移动 `fast` 指针时检查 |

### 翻转单链表

#### 删除+插入

代码实现见`Reverse the Linked List (delete&insert).cpp`文件。

代码思想：

1. **初始化新链表**：创建一个新的链表头节点，初始时这个新链表为空。

2. **遍历原链表**：遍历原始链表，每次循环中从原链表的头部删除一个节点。

3. **插入节点到新链表**：将刚刚从原链表删除的节点插入到新链表的头部。

4. **重复操作**：重复以上操作，直到原链表为空。

5. **更新原链表头指针**：最后，将原链表的头指针更新为新链表的头指针，完成翻转。

#### 指针重排

代码实现见`Reverse the Linked List (Rearrange Pointers).cpp`文件。

代码思想：

1. **初始化三个指针**：
   - `prev`：指向当前节点的前一个节点，初始时为 `nullptr`。
   - `current`：指向当前处理的节点，初始时为 `head`。
   - `next`：暂时存储 `current` 节点的下一个节点。

2. **遍历链表**：
   - 在链表上遍历，对每个节点进行操作。

3. **调整指针**：
   - 在每次迭代中，首先保存 `current->next` 到 `next`。
   - 将 `current->next` 设置为 `prev`，实现指针反向。
   - 移动 `prev` 和 `current` 指针，继续遍历。

4. **完成翻转**：
   - 当 `current` 到达链表尾部（`nullptr`）时，`prev` 将指向新的头节点。

#### “删除+插入”与指针重排法的比较

| 特性/方法       | 删除+插入                 | 指针重排                 |
|-----------------|--------------------------|--------------------------|
| 遍历次数         | 一次                      | 一次                      |
| 时间复杂度       | \(O(n)\)                 | \(O(n)\)                 |
| 空间复杂度       | \(O(1)\)                 | \(O(1)\)                 |
| 实现复杂度       | 中等                      | 简单                      |
| 操作             | 删除原链表节点并插入新链表 | 直接调整原链表节点指针     |
| 对原链表的影响   | 破坏原链表                | 不破坏原链表              |
| 适用场景         | 当不需要保留原链表时       | 当需要保留原链表结构时     |

### 双向链表（Doubly Linked List）

#### 双向链表的定义

双向链表是一种更复杂的链表结构，其中每个节点都有两个指针：一个指向前一个节点（`prev`），另一个指向后一个节点（`next`）。这种结构允许在链表中双向遍历，即可以向前也可以向后移动。与单向链表相比，双向链表提供了更大的灵活性，但也带来了更高的内存开销。

#### 双向链表的基本特性

- **前驱指针**：每个节点都有一个 `prev` 指针，指向它的前一个节点。
- **后继指针**：每个节点都有一个 `next` 指针，指向它的后一个节点。
- **头节点和尾节点**：链表有一个头节点（指向第一个节点）和一个尾节点（指向最后一个节点）。
- **双向遍历**：可以从头节点向尾节点遍历，也可以从尾节点向头节点遍历。

#### 双向链表的基本操作

- **插入节点**：在链表中的指定位置插入新节点。
- **删除节点**：删除链表中的指定节点。
- **遍历链表**：从头到尾或从尾到头遍历链表。
- **搜索元素**：在链表中查找特定的元素。

#### 双向链表的代码实现

