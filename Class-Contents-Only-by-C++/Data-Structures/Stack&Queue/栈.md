# 栈（Stack）

<!-- toc -->
- [栈（Stack）](#栈stack)
  - [初步了解栈](#初步了解栈)
    - [栈的定义](#栈的定义)
    - [栈的主要元素](#栈的主要元素)
    - [栈的主要应用](#栈的主要应用)
  - [栈的抽象数据类型](#栈的抽象数据类型)
  - [栈的实现方式](#栈的实现方式)
    - [顺序栈（Sequential Stack）](#顺序栈sequential-stack)
      - [顺序栈的定义](#顺序栈的定义)
      - [顺序栈的特点](#顺序栈的特点)
      - [顺序栈栈顶的确定](#顺序栈栈顶的确定)
      - [顺序栈的上溢和下溢问题](#顺序栈的上溢和下溢问题)
      - [顺序栈的代码实现](#顺序栈的代码实现)
    - [链式栈（Linked Stack）](#链式栈linked-stack)
      - [链式栈的定义](#链式栈的定义)
      - [链式栈的特点](#链式栈的特点)
      - [链式栈的代码实现](#链式栈的代码实现)
    - [顺序栈与链式栈的比较](#顺序栈与链式栈的比较)

## 初步了解栈

### 栈的定义

栈（Stack）是一种特殊的线性数据结构，它遵循**后进先出**（LIFO, Last In First Out）的原则。这意味着最后添加进栈的元素将是第一个被移除的。栈限制了数据的访问方式，只能在**一个端口**（栈顶）进行数据的插入和删除操作。

### 栈的主要元素

1. **栈顶（Top）**：栈的操作都在栈顶进行。新元素添加到栈顶，被称为“入栈”或“压栈”（push）。当从栈中移除元素时，也是从栈顶移除，这个操作称为“出栈”或“弹出”（pop）。

2. **栈底（Bottom）**：栈的另一端称为栈底，它是最先加入栈的元素所在的位置。在栈底的元素会最后被移除。

3. **空栈（Empty Stack）**：没有任何元素的栈称为空栈。

### 栈的主要应用

- **进制转换**：利用栈来存储和逆转数字序列。
- **括号匹配**：检查程序中括号是否正确配对。
- **表达式求值**：计算如后缀表达式的值。
- **函数调用**：计算机内部使用栈来处理函数调用，特别是递归函数。
- **深度优先搜索（DFS）**：在图和树的搜索中使用栈来追踪访问路径。

## 栈的抽象数据类型

1. **数据对象**：
   - 集合 \(\{ a_i | a_i \in \text{ElemSet}, i = 1, 2, \ldots, n, n > 0 \}\) 或空集 \(\Phi\)。这里，\(\text{ElemSet}\) 是元素的集合，可以包含任意类型的数据。

2. **数据关系**：
   - 栈中的元素之间存在有序的线性关系 \(\{<a_i, a_{i+1}> | a_i, a_{i+1} \in \text{ElemSet}, i = 0, 1, \ldots, n-2 \}\)。在这个关系中，每个元素 \(a_i\) 都与其下一个元素 \(a_{i+1}\) 相关联。

3. **基本操作**：
   - `InitStack(stack)`：初始化一个空栈 `stack`。
   - `DestroyStack(stack)`：销毁栈 `stack`，释放其占用的所有空间。
   - `Clear(stack)`：清空栈 `stack`。
   - `IsEmpty(stack)`：如果栈 `stack` 为空，则返回真（true）；否则返回假（false）。
   - `IsFull(stack)`：如果栈 `stack` 已满，则返回真（true）；否则返回假（false）。
   - `Top(stack)`：返回栈 `stack` 的栈顶元素，但不改变栈顶元素。
   - `Push(stack, x)`：将元素 `x` 压入栈 `stack`，成为新的栈顶。
   - `Pop(stack)`：将栈顶元素从栈 `stack` 中弹出。

4. **ADT的C++实现**：
见`The ADT of Stack.cpp`文件。

## 栈的实现方式

### 顺序栈（Sequential Stack）

#### 顺序栈的定义

顺序栈是栈的一种实现方式，它使用一段连续的内存空间来存储栈中的元素。这种实现方式通常使用**数组**来完成。在顺序栈中，元素的入栈（push）和出栈（pop）操作都在栈的一端进行，这一端称为“栈顶”。

#### 顺序栈的特点

- **固定容量**：顺序栈的大小在初始化时就**固定**了，它由数组的大小决定。
- **连续的内存空间**：所有元素都存储在一块**连续**的内存区域内。
- **高效的访问和操作**：入栈和出栈操作的时间复杂度都是 \(O(1)\)，因为只涉及到对数组索引的操作。
- **空间利用率**：由于容量固定，可能存在空间浪费的情况，或者在元素数量超过容量时无法继续入栈。

#### 顺序栈栈顶的确定

- **栈顶在数组末尾**：这是最常见的实现方式。栈顶对应于数组的最后一个元素，每次入栈和出栈都在数组的末端进行。
  
- **栈顶在数组头处**：这种方式较少见。栈顶对应于数组的第一个元素，这种方式每次入栈和出栈都需要移动栈中的所有元素，效率较低。

#### 顺序栈的上溢和下溢问题

- **上溢（Stack Overflow）**：当尝试向一个已经满了的栈中添加元素时，会发生上溢。在顺序栈中，由于容量是固定的，一旦入栈的元素超过这个容量，就会发生上溢。
- **下溢（Stack Underflow）**：当尝试从一个空栈中取出元素时，会发生下溢。由于栈中没有元素可以出栈，这种操作是非法的。

#### 顺序栈的代码实现

见`Sequential Stack.cpp`文件。

### 链式栈（Linked Stack）

#### 链式栈的定义

链式栈是栈的另一种实现方式，它使用节点（Node）通过指针相连来存储数据。每个节点包含两部分：一部分存储数据元素，另一部分存储指向下一个节点的指针。在链式栈中，栈顶的位置是变化的，而栈底指向一个固定的哨兵节点或为空。

![Linked Stack](images/Linked%20Stack.jpg)

#### 链式栈的特点

- **动态大小**：链式栈的大小不是固定的，可以根据需要**动态增长或减少**。
- **非连续存储**：栈中的元素不是连续存储的，而是通过**指针链接**的。
- **高效的操作**：入栈和出栈操作通常都是 \(O(1)\) 的时间复杂度，因为只涉及指针的改变。
- **额外的内存开销**：由于每个元素都需要**额外的空间来存储指针**，因此相对于顺序栈，链式栈的内存开销更大。

#### 链式栈的代码实现

见`Linked Stack.cpp`文件。

### 顺序栈与链式栈的比较

| 特性           | 顺序栈                        | 链式栈                        |
| -------------- | ---------------------------- | ---------------------------- |
| **内存分配**   | 静态分配：固定大小的数组      | 动态分配：根据需要分配节点    |
| **容量限制**   | 容量固定                      | 容量可变，受系统内存限制      |
| **存储方式**   | 连续存储                      | 非连续存储                    |
| **空间效率**   | 可能浪费空间或遇到栈溢出问题  | 更高的空间利用率，但每个元素需要额外存储指针 |
| **时间效率**   | 入栈、出栈操作通常较快        | 入栈、出栈操作通常较快        |
| **实现复杂度** | 简单                          | 相对复杂                      |
| **扩展性**     | 受限于初始容量设定            | 根据需要动态扩展              |
| **适用场景**   | 当栈的最大元素数量可预知时    | 当栈的大小不确定或频繁变动时  |
