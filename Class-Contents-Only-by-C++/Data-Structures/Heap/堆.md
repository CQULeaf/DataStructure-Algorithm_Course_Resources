# 堆（Heap）

<!-- toc -->
- [堆（Heap）](#堆heap)
  - [优先级队列（Priority Queue）](#优先级队列priority-queue)
    - [优先级队列的定义](#优先级队列的定义)
    - [优先级队列的ADT](#优先级队列的adt)
    - [优先级队列的实现](#优先级队列的实现)
  - [二叉堆（Binary Heap）](#二叉堆binary-heap)
    - [二叉堆的定义](#二叉堆的定义)
    - [二叉堆的特点](#二叉堆的特点)
    - [二叉堆的存储方式](#二叉堆的存储方式)
    - [二叉堆的基本操作及代码实现](#二叉堆的基本操作及代码实现)
  - [优先级队列的应用](#优先级队列的应用)
    - [优先级队列的应用I：哈夫曼树的构建](#优先级队列的应用i哈夫曼树的构建)
    - [优先级队列的应用II：堆排序](#优先级队列的应用ii堆排序)
    - [优先级队列的应用III：多路归并](#优先级队列的应用iii多路归并)
  - [\*可并堆（Meldable Heap）](#可并堆meldable-heap)
    - [可并堆的定义](#可并堆的定义)
    - [可并堆的主要特点](#可并堆的主要特点)
    - [常见类型的可并堆](#常见类型的可并堆)
    - [合并操作的实现](#合并操作的实现)
    - [可并堆的使用场景](#可并堆的使用场景)
  - [最大最小堆（Min-Max Heap）\& 最小最大堆（Max-Min Heap）](#最大最小堆min-max-heap-最小最大堆max-min-heap)
    - [两者的基本概念](#两者的基本概念)
    - [核心特性](#核心特性)
    - [两者的基本操作](#两者的基本操作)
    - [两者的时间复杂度](#两者的时间复杂度)
    - [两者的应用场景](#两者的应用场景)
  - [对顶堆（Two-Ended Heap）](#对顶堆two-ended-heap)
    - [对顶堆的基本概念](#对顶堆的基本概念)
    - [对顶堆的核心特性](#对顶堆的核心特性)
    - [对顶堆的基本操作](#对顶堆的基本操作)
    - [对顶堆的应用场景](#对顶堆的应用场景)

## 优先级队列（Priority Queue）

### 优先级队列的定义

优先级队列（Priority Queue）是一种特殊的队列，它的主要特点是元素的出队顺序是按照元素的优先级来决定的，而不是元素进入队列的先后顺序。在优先级队列中，每个元素都有一个优先级，优先级最高的元素最先出队。

### 优先级队列的ADT

优先级队列的抽象数据类型（ADT）定义了优先级队列的数据对象、数据关系和基本操作。

1. **数据对象**：元素取自全集 \( U \) 的可重集合 \( E \)，表示优先级队列中包含的元素。

2. **数据关系**：全集 \( U \) 中的元素须满足严格弱序，即元素间可以比较优先级。

3. **基本操作**：
   - `Insert(pq, x)`：在优先级队列 \( pq \) 中插入元素 \( x \)。
   - `ExtractMin(pq)`：从优先级队列 \( pq \) 中删除优先级最高（也就是值最小）的元素，并返回该元素。
   - `ExtractMax(pq)`：从优先级队列 \( pq \) 中删除优先级最高（也就是值最大）的元素，并返回该元素。
   - `PeekMin(pq)`：返回优先级队列 \( pq \) 中优先级最高的元素（元素仍然保留在优先级队列中）。
   - `PeekMax(pq)`：返回优先级队列 \( pq \) 中优先级最高的元素（元素仍然保留在优先级队列中）。

### 优先级队列的实现

在实现优先级队列时，虽然可以使用线性结构如链表或数组，但这种实现方式在出队操作时需要遍历所有元素以找到优先级最高的元素，其时间复杂度为 \( O(n) \)，效率较低。因此，更常见的做法是使用二叉堆（Binary Heap）等更高效的数据结构来实现优先级队列，这样可以将出队操作的时间复杂度降低到 \( O(\log n) \)。

## 二叉堆（Binary Heap）

### 二叉堆的定义

二叉堆（Binary Heap）是一种特殊的完全二叉树，主要用于实现优先级队列。它由 J. W. J. Williams 于 1964 年提出，最初是为了支持堆排序算法。二叉堆可以分为两种类型：最小堆（Min Heap）和最大堆（Max Heap），它们的特性如下：

1. **最小堆（Min Heap）**：
   - 在最小堆中，任何一个父节点的值都不大于其子节点的值。
   - 这意味着堆的根节点（即堆顶）是所有节点中的最小值。

2. **最大堆（Max Heap）**：
   - 在最大堆中，任何一个父节点的值都不小于其子节点的值。
   - 这意味着堆的根节点是所有节点中的最大值。

### 二叉堆的特点

- **完全二叉树结构**：二叉堆是一种完全二叉树，这意味着除了最后一层外，每一层都是完全填满的，且最后一层的节点尽可能地集中在左侧。
- **父子节点的关系**：
  - 结点 \( i \) 的左子节点的下标是 \( 2i \)（如果存在）。
  - 结点 \( i \) 的右子节点的下标是 \( 2i + 1 \)（如果存在）。
  - 结点 \( i \) 的父节点的下标是 \( i/2 \)（如果存在）。

### 二叉堆的存储方式

- 由于二叉堆是完全二叉树，它可以有效地在数组中存储，无需使用指针。根节点存储在数组的第一个位置（有时为了计算方便，也会将根节点存储在数组的第二个位置，即下标为 1 的位置）。

### 二叉堆的基本操作及代码实现

- 上调（Sift Up）操作
  1. 比较当前结点 \( i \) 与其父结点 \( p \) 的值。如果当前结点的值小于父结点的值（对于最小堆），则需要调整。
  2. 将当前结点的值向上移动，即将父结点的值下移，而不是直接交换两个结点的值。
  3. 重复以上步骤，直到当前结点移动到根结点或者满足堆的性质（即当前结点的值不小于父结点的值）。

- 下调（Sift Down）操作
  1. 比较当前结点 \( i \) 与其子结点的值。如果当前结点的值大于其子结点的值（对于最小堆），则需要调整。
  2. 如果有两个子结点，选择两者中较小的一个与当前结点进行比较。
  3. 将当前结点的值向下移动，将较小的子结点的值上移。
  4. 重复以上步骤，直到当前结点移动到叶子结点或满足堆的性质。

- 插入操作
  1. 将新元素添加到堆的末尾。
  2. 使用上调操作将新元素移动到合适的位置。

- 删除操作
  1. 删除堆顶元素（对于最小堆，堆顶是最小值）。
  2. 将堆的最后一个元素移动到堆顶。
  3. 使用下调操作将新的堆顶元素移动到合适的位置。

- 快速建堆操作
  1. 从最后一个非叶子结点开始，对每个结点应用下调操作。
  2. 逐步上移至根结点。

- 朴素建堆操作
  1. 从数组的第二个元素开始。因为在二叉堆的数组表示中，索引为 1 的位置是根节点，它没有父节点，因此不需要上调。
  2. 依次遍历数组中的每个元素，对每个元素执行上调操作。
  3. 重复这个过程，直到数组的最后一个元素。

***代码实现见`Basic Operation of Binary Heap.cpp`文件。***

## 优先级队列的应用

### 优先级队列的应用I：哈夫曼树的构建

在“树-哈夫曼树的构建”已详细说明。

### 优先级队列的应用II：堆排序

在“排序-选择排序-堆排序”已详细说明。

### 优先级队列的应用III：多路归并

在“排序-归并排序”已详细说明。

## *可并堆（Meldable Heap）

### 可并堆的定义

一种特殊类型的堆，设计用于有效地支持堆的合并操作。这在某些算法中非常重要，尤其是当需要频繁地合并两个堆时。相比于传统的二叉堆，可并堆在合并两个堆时更加高效。

### 可并堆的主要特点

1. **高效的合并操作**：可并堆的主要特点是能够高效地合并两个堆，这通常是其最基本的操作之一。

2. **不规则的形状**：与二叉堆的规则完全二叉树形状不同，可并堆通常具有不规则的形状。

3. **指针表示法**：因为其形状的不规则性，可并堆在实现时通常需要使用指针来表示节点之间的连接关系。

4. **基本操作**：
   - **合并（Meld）**：合并是可并堆的核心操作，用于将两个堆合并成一个。
   - **插入**：通过将新元素创建为单节点堆，然后将其与现有堆合并来实现。
   - **删除**：删除操作通常涉及到从堆中移除节点后，将产生的子树合并回堆中。

### 常见类型的可并堆

- **左堆（Leftist Heap）**：左堆通过维护外节点路径长度的方法来优化合并操作。左堆的合并操作时间复杂度是 \( O(\log n) \)。

- **斜堆（Skew Heap）**：斜堆是左堆的一个变种，它减少了维护信息的需要。斜堆的合并操作同样是 \( O(\log n) \)。

- **二项堆（Binomial Heap）**：二项堆由一系列满足特定性质的二项树组成。合并操作是通过合并这些二项树来实现的，时间复杂度也是 \( O(\log n) \)。

### 合并操作的实现

合并操作是可并堆的核心，其实现通常依赖于特定类型的堆的结构。例如，在左堆或斜堆中，合并操作通常涉及到比较根节点的值，然后递归地合并子堆。在二项堆中，合并则是通过合并相同大小的二项树来实现的。

### 可并堆的使用场景

可并堆在需要频繁合并堆的场景中非常有用，如图算法、优先队列的合并等。它们提供了一种比传统二叉堆更高效的合并机制，尤其是在处理大量元素时。

## 最大最小堆（Min-Max Heap）& 最小最大堆（Max-Min Heap）

### 两者的基本概念

最小最大堆（Min-Max Heap）和最大最小堆（Max-Min Heap）是两种特殊的堆结构，它们结合了最小堆和最大堆的特性，能够同时高效地获取堆中的最小值和最大值。

### 核心特性

1. **完全二叉树**：都是完全二叉树结构。
2. **交替层次最小/最大属性**：
   - 最小最大堆：偶数层（包括根层，第0层）的节点小于其所有后代，奇数层的节点大于其所有后代。
   - 最大最小堆：与最小最大堆相反，偶数层的节点大于其所有后代，奇数层的节点小于其所有后代。

![Min-Max Heap](images/Min-Max%20Heap.png)

### 两者的基本操作

1. **插入（Insert）**：插入到末尾，然后上调，可能涉及跨层比较。
2. **查询最小/最大元素（PeekMin/PeekMax）**：
   - 最小最大堆：最小元素在根，最大元素在根的子节点之一。
   - 最大最小堆：最大元素在根，最小元素在根的子节点之一。
3. **删除最小/最大元素（ExtractMin/ExtractMax）**：将末尾元素移至相应位置，然后下调。

### 两者的时间复杂度

- **插入和删除操作**：均为 \( O(\log n) \)。

### 两者的应用场景

适用于需要同时快速访问和删除最小值和最大值的情况，如某些优先队列应用。这两种堆结构提供了在同一数据结构中处理最小值和最大值操作的灵活性。

## 对顶堆（Two-Ended Heap）

### 对顶堆的基本概念

对顶堆（Two-Ended Heap）是一种特殊的数据结构，由一个最大堆和一个最小堆组成，主要用于高效地解决第 \( k \) 大或第 \( k \) 小的问题。

### 对顶堆的核心特性

1. **两个堆的结构**：由一个最大堆和一个最小堆组成，最大堆维护最小的 \( k \) 个元素，最小堆维护剩下的元素。
2. **形象比喻**：可以想象为两个三角形的顶点对顶点扣在一起。

![Two-Ended Heap](images/Two-Ended%20Heap.png)

### 对顶堆的基本操作

1. **获取第 \( k \) 小的元素**：最大堆的堆顶元素即是第 \( k \) 小的元素。
2. **插入元素**：
   - 如果元素小于最大堆的堆顶元素，插入到最大堆中。
   - 如果元素大于最大堆的堆顶元素，插入到最小堆中。
   - 保持两个堆的大小平衡（可能需要移动堆顶元素）。
3. **删除元素**：
   - 如果元素在最大堆中，从最大堆删除。
   - 如果元素在最小堆中，从最小堆删除。
   - 保持两个堆的大小平衡。

### 对顶堆的应用场景

对顶堆适用于需要同时处理最小值和最大值的情况，尤其是对动态数据集进行第 \( k \) 大或第 \( k \) 小元素查询时非常有效。例如，在数据流中寻找中位数或其他顺序统计量时，对顶堆提供了一个既高效又灵活的解决方案。
