# 堆（Heap）

<!-- toc -->
- [堆（Heap）](#堆heap)
  - [优先级队列（Priority Queue）](#优先级队列priority-queue)
    - [优先级队列的定义](#优先级队列的定义)
    - [优先级队列的ADT](#优先级队列的adt)
    - [优先级队列的实现](#优先级队列的实现)
  - [二叉堆（Binary Heap）](#二叉堆binary-heap)
    - [二叉堆的定义](#二叉堆的定义)
    - [二叉堆的特点](#二叉堆的特点)
    - [二叉堆的存储方式](#二叉堆的存储方式)
    - [二叉堆的基本操作及代码实现](#二叉堆的基本操作及代码实现)

## 优先级队列（Priority Queue）

### 优先级队列的定义

优先级队列（Priority Queue）是一种特殊的队列，它的主要特点是元素的出队顺序是按照元素的优先级来决定的，而不是元素进入队列的先后顺序。在优先级队列中，每个元素都有一个优先级，优先级最高的元素最先出队。

### 优先级队列的ADT

优先级队列的抽象数据类型（ADT）定义了优先级队列的数据对象、数据关系和基本操作。

1. **数据对象**：元素取自全集 \( U \) 的可重集合 \( E \)，表示优先级队列中包含的元素。

2. **数据关系**：全集 \( U \) 中的元素须满足严格弱序，即元素间可以比较优先级。

3. **基本操作**：
   - `Insert(pq, x)`：在优先级队列 \( pq \) 中插入元素 \( x \)。
   - `ExtractMin(pq)`：从优先级队列 \( pq \) 中删除优先级最高（也就是值最小）的元素，并返回该元素。
   - `ExtractMax(pq)`：从优先级队列 \( pq \) 中删除优先级最高（也就是值最大）的元素，并返回该元素。
   - `PeekMin(pq)`：返回优先级队列 \( pq \) 中优先级最高的元素（元素仍然保留在优先级队列中）。
   - `PeekMax(pq)`：返回优先级队列 \( pq \) 中优先级最高的元素（元素仍然保留在优先级队列中）。

### 优先级队列的实现

在实现优先级队列时，虽然可以使用线性结构如链表或数组，但这种实现方式在出队操作时需要遍历所有元素以找到优先级最高的元素，其时间复杂度为 \( O(n) \)，效率较低。因此，更常见的做法是使用二叉堆（Binary Heap）等更高效的数据结构来实现优先级队列，这样可以将出队操作的时间复杂度降低到 \( O(\log n) \)。

## 二叉堆（Binary Heap）

### 二叉堆的定义

二叉堆（Binary Heap）是一种特殊的完全二叉树，主要用于实现优先级队列。它由 J. W. J. Williams 于 1964 年提出，最初是为了支持堆排序算法。二叉堆可以分为两种类型：最小堆（Min Heap）和最大堆（Max Heap），它们的特性如下：

1. **最小堆（Min Heap）**：
   - 在最小堆中，任何一个父节点的值都不大于其子节点的值。
   - 这意味着堆的根节点（即堆顶）是所有节点中的最小值。

2. **最大堆（Max Heap）**：
   - 在最大堆中，任何一个父节点的值都不小于其子节点的值。
   - 这意味着堆的根节点是所有节点中的最大值。

### 二叉堆的特点

- **完全二叉树结构**：二叉堆是一种完全二叉树，这意味着除了最后一层外，每一层都是完全填满的，且最后一层的节点尽可能地集中在左侧。
- **父子节点的关系**：
  - 结点 \( i \) 的左子节点的下标是 \( 2i \)（如果存在）。
  - 结点 \( i \) 的右子节点的下标是 \( 2i + 1 \)（如果存在）。
  - 结点 \( i \) 的父节点的下标是 \( i/2 \)（如果存在）。

### 二叉堆的存储方式

- 由于二叉堆是完全二叉树，它可以有效地在数组中存储，无需使用指针。根节点存储在数组的第一个位置（有时为了计算方便，也会将根节点存储在数组的第二个位置，即下标为 1 的位置）。

### 二叉堆的基本操作及代码实现

- 上调（Sift Up）操作
  1. 比较当前结点 \( i \) 与其父结点 \( p \) 的值。如果当前结点的值小于父结点的值（对于最小堆），则需要调整。
  2. 将当前结点的值向上移动，即将父结点的值下移，而不是直接交换两个结点的值。
  3. 重复以上步骤，直到当前结点移动到根结点或者满足堆的性质（即当前结点的值不小于父结点的值）。

- 下调（Sift Down）操作
  1. 比较当前结点 \( i \) 与其子结点的值。如果当前结点的值大于其子结点的值（对于最小堆），则需要调整。
  2. 如果有两个子结点，选择两者中较小的一个与当前结点进行比较。
  3. 将当前结点的值向下移动，将较小的子结点的值上移。
  4. 重复以上步骤，直到当前结点移动到叶子结点或满足堆的性质。

- 插入操作
  1. 将新元素添加到堆的末尾。
  2. 使用上调操作将新元素移动到合适的位置。

- 删除操作
  1. 删除堆顶元素（对于最小堆，堆顶是最小值）。
  2. 将堆的最后一个元素移动到堆顶。
  3. 使用下调操作将新的堆顶元素移动到合适的位置。

- 朴素建堆操作
  1. 从最后一个非叶子结点开始，对每个结点应用下调操作。
  2. 逐步上移至根结点。

***代码实现见`Basic Operation of Binary Heap.cpp`文件。
